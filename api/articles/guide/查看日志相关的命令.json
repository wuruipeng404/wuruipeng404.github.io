{"title":"查看日志相关的命令","uid":"517d2648b07f96d72267ed192f3c0c92","slug":"guide/查看日志相关的命令","date":"2020-11-18T07:38:28.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/查看日志相关的命令.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>作为一名开发，查询过滤日志去debug 应该是基本功中的基本功了。今天详细介绍一下这些命令</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-head\"><a href=\"#1-head\" class=\"headerlink\" title=\"1. head\"></a>1. head</h3><p>  <code>head</code> 与 <code>tail</code> 是一对命令，从字面意思也可以看出其作用<br>  <code>head</code> 是用来查看头部的内容，<code>tail</code> 用来查看尾部的内容<br>  参数：<br>    - <code>-q</code> 隐藏文件名<br>    - <code>-v</code> 显示文件名<br>    - <code>-c &lt;字节&gt;</code> 显示字节数<br>    - <code>-n &lt;行数&gt;</code> 显示行数</p>\n<h3 id=\"2-tail\"><a href=\"#2-tail\" class=\"headerlink\" title=\"2. tail\"></a>2. tail</h3><p>  这个相较与 <code>head</code> 就用的比较多了<br>  参数：</p>\n<ul>\n<li><code>-f</code> 循环读取</li>\n<li><code>-q</code> 不显示处理信息</li>\n<li><code>-v</code> 显示详细的处理信息</li>\n<li><code>-c&lt;数目&gt;</code> 显示的字节数no</li>\n<li><code>-n&lt;行数&gt;</code> 显示文件的尾部 n 行内容</li>\n<li><code>--pid=PID</code>与<code>-f</code>合用,表示在进程ID,PID死掉之后结束</li>\n<li><code>-q, --quiet, --silent</code> 从不输出给出文件名的首部</li>\n<li><code>-s, --sleep-interval=S</code> 与-f合用,表示在每次反复的间隔休眠S秒</li>\n</ul>\n<h3 id=\"3-grep\"><a href=\"#3-grep\" class=\"headerlink\" title=\"3. grep\"></a>3. grep</h3><p>  grep用来过滤输出<br>  参数：</p>\n<ul>\n<li><code>-a,--text</code> 不忽略二进制的数据。</li>\n<li><code>-A&lt;显示行数&gt;,--after-context=&lt;显示行数&gt;</code> 显示匹配值之后的n行内容</li>\n<li><code>-b,--byte-offset</code> 标示出该行第一个字符的编号。</li>\n<li><code>-B&lt;显示行数&gt;,--before-context=&lt;显示行数&gt;</code> 显示匹配值之前的n行内容</li>\n<li><code>-c,--count</code> 计算符合样式的列数。</li>\n<li><code>-C&lt;显示行数&gt;,--context=&lt;显示行数&gt;或-&lt;显示行数&gt;</code> 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li>\n<li><code>-d &lt;动作&gt;,--directories=&lt;动作&gt;</code> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>\n<li><code>-e&lt;范本样式&gt;,--regexp=&lt;范本样式&gt;</code> 指定字符串做为查找文件内容的样式。</li>\n<li><code>-E,--extended-regexp</code> 将样式为延伸的正则表达式来使用。</li>\n<li><code>-f&lt;规则文件&gt;,--file=&lt;规则文件&gt;</code> 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li>\n<li><code>-F,--fixed-regexp</code> 将样式视为固定字符串的列表。</li>\n<li><code>-G,--basic-regexp</code> 将样式视为普通的表示法来使用。</li>\n<li><code>-h,--no-filename</code> 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li>\n<li><code>-H,--with-filename</code> 在显示符合样式的那一行之前，表示该行所属的文件名称。</li>\n<li><code>-i,--ignore-case</code> 忽略字符大小写的差别。</li>\n<li><code>-l,--file-with-matches</code> 列出文件内容符合指定的样式的文件名称。</li>\n<li><code>-L,--files-without-match</code> 列出文件内容不符合指定的样式的文件名称。</li>\n<li><code>-n,--line-number</code> 在显示符合样式的那一行之前，标示出该行的列数编号。</li>\n<li><code>-o,--only-matching</code> 只显示匹配PATTERN 部分。</li>\n<li><code>-q,--quiet或--silent</code> 不显示任何信息。</li>\n<li><code>-r,--recursive</code> 此参数的效果和指定”-d recurse”参数相同。</li>\n<li><code>-s,--no-messages</code> 不显示错误信息。</li>\n<li><code>-v,--revert-match</code> 显示不包含匹配文本的所有行。</li>\n<li><code>-V,--version</code> 显示版本信息。</li>\n<li><code>-w,--word-regexp</code> 只显示全字符合的列。</li>\n<li><code>-x,--line-regexp</code> 只显示全列符合的列。</li>\n<li><code>-y</code> 此参数的效果和指定”-i”参数相同。</li>\n<li><code>-m</code> 匹配多少次</li>\n</ul>\n<h3 id=\"4-Example\"><a href=\"#4-Example\" class=\"headerlink\" title=\"4.Example\"></a>4.Example</h3><ul>\n<li>持续输出最新的 50 行日志  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tail -f -n 20 file.log </code></pre></li>\n<li>持续输出最新 50 行日志中匹配 关键字<code>ss</code>的行  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tail -f -n 50 file.log | grep &quot;ss&quot;</code></pre></li>\n<li>持续输出最新 50 行日志中匹配 关键字<code>ss</code>的行 只匹配3次  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tail -f -n 50 file.log | grep -m 3 &quot;ss&quot;</code></pre></li>\n<li>持续输出最新 50 行日志中匹配 关键字<code>ss</code>的行 只匹配3次,并显示匹配项前后3行的内容  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tail -f -n 50 file.log | grep -3 -m 3 &quot;ss&quot;</code></pre></li>\n</ul>\n","text":"作为一名开发，查询过滤日志去debug 应该是基本功中的基本功了。今天详细介绍一下这些命令 1. head head 与 tail 是一对命令，从字面意思也可以看出其作用 head 是用来查看头部的内容，tail 用来查看尾部的内容 参数： - -q 隐藏文件名 - -v 显示文...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"head","slug":"head","count":1,"path":"api/tags/head.json"},{"name":"grep","slug":"grep","count":1,"path":"api/tags/grep.json"},{"name":"tail","slug":"tail","count":1,"path":"api/tags/tail.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-head\"><span class=\"toc-text\">1. head</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-tail\"><span class=\"toc-text\">2. tail</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-grep\"><span class=\"toc-text\">3. grep</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Example\"><span class=\"toc-text\">4.Example</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"关于Golang高并发高效率代码的一些实践","uid":"771a458cad4b66e91f1476adf7a25646","slug":"golang/关于Golang高并发高效率代码的一些实践","date":"2020-11-18T09:49:19.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/关于Golang高并发高效率代码的一些实践.json","keywords":"golang rust python docker k8s","cover":[],"text":"Go的并发 Go语言是原生支持并发的，它和传统基于OS线程和进程的实现不同，Go语言的并发是基于用户态的并发，这种并发方式就变得非常轻量，能够轻松运行几万甚至是几十万的并发逻辑。因此使用Go开发的服务端应用采用的就是“协程模型”，每一个请求由独立的协程处理完成、 并发模型 Go的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":4,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"},{"name":"高并发","slug":"高并发","count":1,"path":"api/tags/高并发.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"MySQL之MVCC","uid":"94d8fb994bc3cd6f390288bebd2dcdbe","slug":"mysql/MySQL之MVCC","date":"2020-11-11T09:46:56.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL之MVCC.json","keywords":"golang rust python docker k8s","cover":null,"text":"什么是MVCC？ 英文全称为Multi-Version Concurrency Control,即多版本并发控制。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。 原理 MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}