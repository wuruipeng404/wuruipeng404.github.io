{"total":56,"pageSize":12,"pageCount":5,"data":[{"title":"http,https,http2,RPC,gRPC,Socket,WebSocket都是些啥","uid":"d71352f907ccd4a5fa2d2fd4965d3b21","slug":"basic/proto","date":"2022-03-12T06:07:20.000Z","updated":"2022-03-12T09:19:18.274Z","comments":true,"path":"api/articles/basic/proto.json","cover":[],"text":"首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层 http http,https,http2 (统称http) 是应用层协议，主要解决如何包装数据（文本信息），是建立在TCP协议之上的应用。那么这个s,和2分别指的什么呢我们来先...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"网络基础","slug":"网络基础","count":1,"path":"api/categories/网络基础.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},{"title":"封装易用的 Golang Odm","uid":"235660ba99baa3b7d4208214f0acb547","slug":"golang/odm","date":"2022-03-12T04:12:37.000Z","updated":"2022-03-12T05:59:32.181Z","comments":true,"path":"api/articles/golang/odm.json","cover":null,"text":"在golang中目前需要对mongodb进行操作会接触到如下两个库 mongo-go-driver mongodb官方出的驱动mgo mgo 很久没有维护了. 所以现在大家基本上都在使用官方的driver,但是官方的driver用下来,有一些痛点.所以我决定封装一下.使其用起来像...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"},{"name":"mongo","slug":"go/mongo","count":1,"path":"api/categories/go/mongo.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"mongodb","slug":"mongodb","count":1,"path":"api/tags/mongodb.json"},{"name":"odm","slug":"odm","count":1,"path":"api/tags/odm.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},{"title":"k8s之heketi(四)","uid":"24fa801b1de3778c9ca42278460e2c33","slug":"k8s/4.k8s之Heketi","date":"2021-01-06T06:07:06.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/4.k8s之Heketi.json","cover":null,"text":"前言 在上一篇中，我们搭建了GlusterFS分布式存储集群。其实搭建好之后就可以创建PV以及PVC进行使用了。但是K8S更进一步的提供一个高级抽象StorageClass, 他主要的作用是对用户设置的PVC申请屏 蔽后端存储的细节，一方面减少了用户对于存储资源细节的关注，另一方...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"heketi","slug":"heketi","count":1,"path":"api/tags/heketi.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},{"title":"k8s之共享存储(GlusterFS)(三)","uid":"60ad9b5a7955245986176acd6be5e193","slug":"k8s/3.k8s之共享存储","date":"2020-12-25T05:26:26.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/3.k8s之共享存储.json","cover":null,"text":"K8S共享存储介绍 K8S 对于有状态的容器应用 或者 需要数据持久化的数据应用，不仅需要将容器内的目录挂载到宿主机的目录或者emptyDir临时存储卷，而且需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。 为了方便使用和管理，K8S实现...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"k8s之基础概念理解(二)","uid":"3ded30373967d6211e6c798b6bf7e484","slug":"k8s/2.k8s之基础概念理解","date":"2020-12-07T06:12:09.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/2.k8s之基础概念理解.json","cover":[],"text":"本篇主要来解释一下k8s繁多的概念 我觉得吧第一遍不用一定要全部理解，先大致过一下，以后会慢慢熟悉 K8S中的概念按我的理解把他分为这样两类： 架构类：所谓架构类，就是指K8S自身部署，调度，的一些组件和概念 服务类：就是针对我们自己的服务调度，部署，控制，所用到的概念 架构类 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"记一次磁盘满后引发的血案","uid":"0fd644d7a8607c81bbe89c11e736a98e","slug":"work/记一次磁盘满后引发的血案","date":"2020-12-07T05:37:12.000Z","updated":"2021-12-11T02:10:04.781Z","comments":true,"path":"api/articles/work/记一次磁盘满后引发的血案.json","cover":null,"text":"概要 微服务项目， 部署于docker swarm集群 docker swarm集群 是一台物理服务器 + 物理服务器自身虚拟出来的 四个节点，也就是总共五个节点所组成。 我们的中间件有 ELK, MySQL, Redis, RabbitMQ, DFS, ETCD，+上 大量的服...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"work-record","slug":"work-record","count":1,"path":"api/categories/work-record.json"}],"tags":[{"name":"工作记录","slug":"工作记录","count":1,"path":"api/tags/工作记录.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"k8s之搭建环境(一)","uid":"3ecf53fd0f043e7fd47d014c92e0e74b","slug":"k8s/1.k8s之搭建环境","date":"2020-11-27T05:18:17.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/1.k8s之搭建环境.json","cover":[],"text":"flag:从今天开始，我将更新K8S系列博文，从环境搭建，到K8S概念的详解，到在k8s上部署完整项目，乃至有可能对K8S的二次开发。未来可期 MAC1. 安装docker-desktop，这个没什么好说的 docker 2. 配置镜像仓库源进行加速 可以选择的源有很多 dock...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"关于Golang高并发高效率代码的一些实践","uid":"771a458cad4b66e91f1476adf7a25646","slug":"golang/关于Golang高并发高效率代码的一些实践","date":"2020-11-18T09:49:19.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/关于Golang高并发高效率代码的一些实践.json","cover":[],"text":"Go的并发 Go语言是原生支持并发的，它和传统基于OS线程和进程的实现不同，Go语言的并发是基于用户态的并发，这种并发方式就变得非常轻量，能够轻松运行几万甚至是几十万的并发逻辑。因此使用Go开发的服务端应用采用的就是“协程模型”，每一个请求由独立的协程处理完成、 并发模型 Go的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"高并发","slug":"高并发","count":1,"path":"api/tags/高并发.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"查看日志相关的命令","uid":"517d2648b07f96d72267ed192f3c0c92","slug":"guide/查看日志相关的命令","date":"2020-11-18T07:38:28.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/查看日志相关的命令.json","cover":null,"text":"作为一名开发，查询过滤日志去debug 应该是基本功中的基本功了。今天详细介绍一下这些命令 1. head head 与 tail 是一对命令，从字面意思也可以看出其作用 head 是用来查看头部的内容，tail 用来查看尾部的内容 参数： - -q 隐藏文件名 - -v 显示文...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"head","slug":"head","count":1,"path":"api/tags/head.json"},{"name":"grep","slug":"grep","count":1,"path":"api/tags/grep.json"},{"name":"tail","slug":"tail","count":1,"path":"api/tags/tail.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"MySQL之MVCC","uid":"94d8fb994bc3cd6f390288bebd2dcdbe","slug":"mysql/MySQL之MVCC","date":"2020-11-11T09:46:56.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL之MVCC.json","cover":null,"text":"什么是MVCC？ 英文全称为Multi-Version Concurrency Control,即多版本并发控制。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。 原理 MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"python调用rust与go生成的库文件","uid":"9675eb8263b3ddc03bf1d31763c2e083","slug":"rust/python-rust-go","date":"2020-11-11T03:09:44.000Z","updated":"2021-12-11T02:10:04.781Z","comments":true,"path":"api/articles/rust/python-rust-go.json","cover":[],"text":"Python,Rust,Go 我最喜欢的三门语言。 今天来搞一下 分别用rust&amp;&amp;go生成.so文件供python调用，顺便简单测试一下他们之间的性能差距 版本 Python: 3.8.6 Go: 1.15.3 Rust: 1.49.0-nightly (25f...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"rust","slug":"rust","count":1,"path":"api/categories/rust.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"},{"name":"rust","slug":"rust","count":1,"path":"api/tags/rust.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"github-ssh协议配置代理","uid":"357905e1891b1f51272b4c207482f185","slug":"guide/github-ssh协议配置代理","date":"2020-11-10T07:10:01.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/github-ssh协议配置代理.json","cover":null,"text":"最近git连github经常抽风 使用 git config --global http.proxy的方式也没用的状态下，就想搞一下ssh协议走代理开搞 配置 .ssh/config Host github.com ProxyCommand ~&#x2F;.ssh&#x2F;ss...","link":"","photos":[],"count_time":{"symbolsCount":493,"symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"git","slug":"git","count":2,"path":"api/tags/git.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}]}