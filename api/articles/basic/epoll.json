{"title":"select poll epoll","uid":"5f7c30e057df77178fa3c740f5edfc89","slug":"basic/epoll","date":"2020-08-13T07:27:09.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/basic/epoll.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>今天被问到epoll机制，倒不是不知道，就是长时间不看他就容易忽略一些细节，导致描述不好。<br>好吧那我们就来复习一下吧。（虽然我向来不是一个面向面试编程的人）-.&#x3D;</p>\n<span id=\"more\"></span>\n<p>首先 select,poll,epoll都是I&#x2F;O多路复用的机制。<br>I&#x2F;O多路复用：通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序（也就是响应的进程）进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>\n<p>关于三者的实现原理这里就不赘述了，善用搜索引擎，很多很多。</p>\n<p>总结一下三者的一些特征与区别</p>\n<ul>\n<li>select<ul>\n<li>监听的fd（文件描述符）有最大限制 <code>cat /proc/sys/fs/file-max</code> 查看，一般默认32位是1024，64位是2048 </li>\n<li>对socket的扫描是轮训扫描，而且不管其是否活跃都会扫描，效率低下，且浪费cpu时间</li>\n<li>需要维护一个存放fd的数据结构，🙆用户空间与内核空间在传递该结构时复制开销大</li>\n</ul>\n</li>\n<li>poll<ul>\n<li>与select相比 仅仅是没有最大连接数的限制，因为是基于链表来实现的。</li>\n</ul>\n</li>\n<li>epoll<ul>\n<li>epoll 没有最大并发连接的显示</li>\n<li>基于事件回调机制，只有活跃的链接才会触发回调，唤醒进程进行处理</li>\n<li>利用mmap()文件映射加速与内核空间的消息传递，减少复制开销</li>\n</ul>\n</li>\n</ul>\n<p>看完了这些区别是不是epoll就万能了呢，当然不是，任何东西，都有其适用场景，比如当链接比较少，而且都是活跃的情况下，select poll自然比epoll效率高。因为epoll需要很多回调</p>\n<p>但是<br>当今这个时代，确实可用 epoll 一把梭。毕竟感觉好像人人都在追求高并发，大流量。</p>\n","text":"今天被问到epoll机制，倒不是不知道，就是长时间不看他就容易忽略一些细节，导致描述不好。好吧那我们就来复习一下吧。（虽然我向来不是一个面向面试编程的人）-.&#x3D; 首先 select,poll,epoll都是I&#x2F;O多路复用的机制。I&#x2F;O多路复用：通过一...","link":"","photos":[],"count_time":{"symbolsCount":816,"symbolsTime":"1 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"epoll","slug":"epoll","count":1,"path":"api/tags/epoll.json"},{"name":"poll","slug":"poll","count":1,"path":"api/tags/poll.json"},{"name":"select","slug":"select","count":1,"path":"api/tags/select.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"计算机基础之网络协议","uid":"bd1810b01d17021ef51e6fe61514d2b5","slug":"basic/计算机基础之网络协议","date":"2020-09-19T09:19:52.000Z","updated":"2022-03-12T06:12:23.355Z","comments":true,"path":"api/articles/basic/计算机基础之网络协议.json","keywords":"golang rust python docker k8s","cover":[],"text":"我们都知道OSI把网络分为了一个7层的模型，OSI是Open System Interconnect的缩写，意为开放式系统互联。 主要是： 应用层（Application） 表示层（Presentation） 会话层（Session） 传输层（Transport） 网络层（Net...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{}}