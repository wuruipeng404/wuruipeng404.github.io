{"title":"k8s之heketi(四)","uid":"24fa801b1de3778c9ca42278460e2c33","slug":"k8s/4.k8s之Heketi","date":"2021-01-06T06:07:06.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/4.k8s之Heketi.json","keywords":"golang rust python docker k8s","cover":null,"content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在上一篇中，我们搭建了GlusterFS分布式存储集群。其实搭建好之后就可以创建PV以及PVC进行使用了。但是K8S更进一步的提供一个高级抽象StorageClass, 他主要的作用是对用户设置的PVC申请屏 蔽后端存储的细节，一方面减少了用户对于存储资源细节的关注，另一方面减轻了管理员手工管理PV的工作，由系统自动完成PV的创建和绑定，实现了动态的资源供应。</p>\n<span id=\"more\"></span>\n<h3 id=\"Heketi\"><a href=\"#Heketi\" class=\"headerlink\" title=\"Heketi\"></a>Heketi</h3><p>  heketi是一个提供RESTful API管理gfs卷的框架，能够在kubernetes、openshift、openstack等云平台上实现动态的存储资源供应，支持gfs多集群管理，便于管理员对gfs进行操作，在kubernetes集群中，pod将存储的请求发送至heketi，然后heketi控制gfs集群创建对应的存储卷。<br>heketi动态在集群内选择bricks构建指定的volumes，以确保副本会分散到集群不同的故障域内。<br>heketi还支持任意数量的glusterfs集群，以保证接入的云服务器不局限于单个glusterfs集群。</p>\n<p>  显而易见 如果我们要使用gfs驱动的StroageClass，就需要通过Heketi了。</p>\n<h3 id=\"安装部署\"><a href=\"#安装部署\" class=\"headerlink\" title=\"安装部署\"></a>安装部署</h3><ul>\n<li><p>我们继续在K8S当中进行部署 heketi 服务,创建<code>heketi.yaml</code></p>\n  <pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1 # 分配账户\nkind: ServiceAccount\nmetadata:\n  name: heketi-service-account\n\n---\n\nkind: Role  # 分配权限\napiVersion: rbac.authorization.k8s.io&#x2F;v1\nmetadata:\n  name: heketi-role\nrules:\n  - apiGroups: [ &quot;&quot; ]\n    resources: [ &quot;pods&quot; ]\n    verbs: [ get,list,watch,create ]\n\n---\n\nkind: RoleBinding # 绑定权限\napiVersion: rbac.authorization.k8s.io&#x2F;v1\nmetadata:\n  name: heketi-rb\nsubjects:\n  - kind: ServiceAccount\n    name: heketi-service-account\nroleRef:\n  kind: Role\n  name: heketi-role\n  apiGroup: rbac.authorization.k8s.io\n\n---\nkind: Deployment\napiVersion: apps&#x2F;v1\nmetadata:\n  name: deploy-heketi\n  labels:\n    glusterfs: heketi-deployment\nspec:\n  selector:\n    matchLabels:\n      name: heketi-deploy\n  replicas: 1\n  template:\n    metadata:\n      name: heketi-deploy\n      labels:\n        name: heketi-deploy\n    spec:\n      nodeSelector:\n        heketi: &quot;yes&quot;\n      serviceAccountName: heketi-service-account\n      containers:\n        - name: heketi\n          image: heketi&#x2F;heketi:latest\n          ports:\n            - containerPort: 8080\n          env:\n            - name: HEKETI_CLI_SERVER\n              value: http:&#x2F;&#x2F;localhost:8080\n          volumeMounts:\n            - mountPath: &quot;&#x2F;var&#x2F;lib&#x2F;heketi&quot;\n              name: db\n          readinessProbe:\n            timeoutSeconds: 3\n            initialDelaySeconds: 3\n            httpGet:\n              port: 8080\n              path: &quot;&#x2F;hello&quot;\n          livenessProbe:\n            timeoutSeconds: 3\n            initialDelaySeconds: 30\n            httpGet:\n              port: 8080\n              path: &quot;&#x2F;hello&quot;\n      volumes:\n        - name: db\n          hostPath:\n            path: &quot;&#x2F;heketi-data&quot;\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: heketi-svc\n  labels:\n    glusterfs: heketi-service\nspec:\n  selector:\n    name: heketi-deploy\n  ports:\n    - port: 8080\n      name: heketi\n      targetPort: 8080</code></pre>\n</li>\n<li><p>执行 <code>kubectl apply -f heketi.yaml</code></p>\n</li>\n<li><p>创建 GFS 集群</p>\n<ul>\n<li>首先编写<code>topology.json</code>文件拷贝并进入到 heketi pod 当中<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;clusters&quot;: [\n    &#123;\n      &quot;nodes&quot;: [\n        &#123;\n          &quot;node&quot;: &#123;\n            &quot;hostnames&quot;: &#123;\n              &quot;manage&quot;: [\n                &quot;k8s-master&quot;\n              ],\n              &quot;storage&quot;: [\n                &quot;192.168.0.1&quot;\n              ]\n            &#125;,\n            &quot;zone&quot;: 1\n          &#125;,\n          &quot;devices&quot;: [\n            &quot;&#x2F;gluster-data&quot;\n          ]\n        &#125;,\n        &#123;\n          &quot;node&quot;: &#123;\n            &quot;hostnames&quot;: &#123;\n              &quot;manage&quot;: [\n                &quot;k8s-node-1&quot;\n              ],\n              &quot;storage&quot;: [\n                &quot;192.168.0.2&quot;\n              ]\n            &#125;,\n            &quot;zone&quot;: 1\n          &#125;,\n          &quot;devices&quot;: [\n            &quot;&#x2F;gluster-data&quot;\n          ]\n        &#125;,\n        &#123;\n          &quot;node&quot;: &#123;\n            &quot;hostnames&quot;: &#123;\n              &quot;manage&quot;: [\n                &quot;k8s-node-2&quot;\n              ],\n              &quot;storage&quot;: [\n                &quot;192.168.0.3&quot;\n              ]\n            &#125;,\n            &quot;zone&quot;: 1\n          &#125;,\n          &quot;devices&quot;: [\n            &quot;&#x2F;gluster-data&quot;\n          ]\n        &#125;\n      ]\n    &#125;\n  ]\n&#125;</code></pre></li>\n<li>执行 <code>heketi-cli --user admin --secret &#39;My Secret&#39; topology load --json=topology.json</code></li>\n<li>查看集群状态 <code>heketi-cli --user admin --secret &#39;My Secret&#39; topology info</code></li>\n</ul>\n</li>\n<li><p>创建 StorageClass</p>\n  <pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">kind: Secret\napiVersion: v1\nmetadata:\n  name: heketi-secret\n  namespace: default\ndata:\n  key: xxxx   # echo -n &quot;your secret&quot; | base64\ntype: kubernetes.io&#x2F;glusterfs\n---\napiVersion: storage.k8s.io&#x2F;v1\nkind: StorageClass\nmetadata:\n  name: heketi-storage-class\nprovisioner: kubernetes.io&#x2F;glusterfs # 必须\nparameters:\n  resturl: &quot;http:&#x2F;&#x2F;ClusterIP:Port&quot;\n  restuser: &quot;admin&quot;\n  secretNamespace: &quot;default&quot;\n  secretName: &quot;heketi-secret&quot; \n  gidMin: &quot;40000&quot;\n  gidMax: &quot;50000&quot;\n  volumetype: &quot;replica:3&quot;</code></pre></li>\n<li><p>PVC申请</p>\n  <pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: pvc-test\nspec:\n  storageClassName: heketi-storage-class\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi</code></pre></li>\n</ul>\n","feature":true,"text":"前言 在上一篇中，我们搭建了GlusterFS分布式存储集群。其实搭建好之后就可以创建PV以及PVC进行使用了。但是K8S更进一步的提供一个高级抽象StorageClass, 他主要的作用是对用户设置的PVC申请屏 蔽后端存储的细节，一方面减少了用户对于存储资源细节的关注，另一方...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"},{"name":"heketi","slug":"heketi","count":1,"path":"api/tags/heketi.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Heketi\"><span class=\"toc-text\">Heketi</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">安装部署</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"k8s之共享存储(GlusterFS)(三)","uid":"60ad9b5a7955245986176acd6be5e193","slug":"k8s/3.k8s之共享存储","date":"2020-12-25T05:26:26.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/3.k8s之共享存储.json","keywords":"golang rust python docker k8s","cover":null,"text":"K8S共享存储介绍 K8S 对于有状态的容器应用 或者 需要数据持久化的数据应用，不仅需要将容器内的目录挂载到宿主机的目录或者emptyDir临时存储卷，而且需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。 为了方便使用和管理，K8S实现...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}