{"title":"关于RabbitMQ消息队列的可靠性传输","uid":"bd281a987a5c824ac404d854e69b882e","slug":"mq/关于RabbitMQ消息队列的可靠性传输","date":"2020-10-28T05:21:20.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mq/关于RabbitMQ消息队列的可靠性传输.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>在使用消息队列的过程中如何保证消息的可靠性呢？<br>这个问题其实包含了几方面的小问题。</p>\n<ol>\n<li>数据丢失问题</li>\n<li>数据幂等性的问题</li>\n<li>重复消费的问题</li>\n</ol>\n<span id=\"more\"></span>\n<p>我们知道在使用消息队列的时候是必然有三个角色的，生产者，消费者，以及MQ本身。<br>那么数据丢失无非就以下几种情况</p>\n<ol>\n<li>生产者传输给MQ 这个过程丢失数据，导致MQ未获取到消息</li>\n<li>MQ收到消息，但是自身宕机，把消息给弄丢了。</li>\n<li>MQ将消息传输给消费者，消费者接收到消息，但是还没处理 挂掉了。导致消息丢失。</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li><p>第一种情况有两种解决办法</p>\n<ol>\n<li>是在生产者开启MQ的事务机制，整个流程和数据库事务差不多，但是这种方法完全不推荐。首先事务机制会大幅降低MQ的吞吐量和性能。其次，我们用MQ本来就是追求一个异步的消息传输过程，当开启事务时，所有的一系列流程就变成了同步阻塞。</li>\n<li>在生产者开启confirm模式(推荐)，开启confirm模式之后 每一条消息mq都会返回给你一个ack信息，用来通知你消息是发送成功还是失败。而且这整个过程是异步的。下面用go的代码做一下示例： <pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n  &quot;fmt&quot;\n  &quot;github.com&#x2F;streadway&#x2F;amqp&quot;\n  &quot;log&quot;\n)\n\nfunc main() &#123;\n  var (\n    err  error\n    conn *amqp.Connection\n    ch   *amqp.Channel\n    q    amqp.Queue\n  )\n  if conn, err &#x3D; amqp.Dial(&quot;amqp:&#x2F;&#x2F;guest:guest@localhost:5672&#x2F;&quot;); err !&#x3D; nil &#123;\n    log.Fatalf(&quot;连接MQ失败:%s&quot;, err.Error())\n  &#125;\n\n  defer func() &#123;\n    _ &#x3D; conn.Close()\n  &#125;()\n\n  &#x2F;&#x2F; 打开一个channel\n  if ch, err &#x3D; conn.Channel(); err !&#x3D; nil &#123;\n    log.Fatalf(&quot;获取channel失败:%s&quot;, err.Error())\n  &#125;\n\n  defer func() &#123;\n    _ &#x3D; ch.Close()\n  &#125;()\n\n  &#x2F;&#x2F; 声名队列\n  if q, err &#x3D; ch.QueueDeclare(\n    &quot;hallo&quot;,\n    false,\n    false,\n    false,\n    false,\n    nil,\n  ); err !&#x3D; nil &#123;\n    log.Fatalf(&quot;声明队列失败:%s&quot;, err.Error())\n  &#125;\n\n  confirm :&#x3D; ch.NotifyPublish(make(chan amqp.Confirmation))\n  if err &#x3D; ch.Confirm(false); err !&#x3D; nil &#123;\n    log.Fatalf(&quot;开启confirm模式失败:%s&quot;, err.Error())\n  &#125;\n\n  go func() &#123;\n    for i :&#x3D; 0; i &lt;&#x3D; 10; i++ &#123;\n      if err &#x3D; ch.Publish(\n        &quot;&quot;,\n        q.Name,\n        false,\n        false,\n        amqp.Publishing&#123;\n          ContentType: &quot;text&#x2F;plain&quot;,\n          Body:        []byte(fmt.Sprintf(&quot;%d&quot;, i)),\n        &#125;,\n      ); err !&#x3D; nil &#123;\n        log.Printf(&quot;推送消息失败:%s&quot;, err.Error())\n        continue\n      &#125;\n    &#125;\n  &#125;()\n\n  for i :&#x3D; 0; i &lt;&#x3D; 10; i++ &#123;\n\n    ack :&#x3D; &lt;-confirm\n    if ack.Ack &#123;\n      &#x2F;&#x2F; 消息发送成功\n    &#125; else &#123;\n      &#x2F;&#x2F; 消息发送失败\n      &#x2F;&#x2F; 写你想要的逻辑\n    &#125;\n    log.Println(ack.DeliveryTag)\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>第二种情况，MQ消息丢失</p>\n<ol>\n<li>这个时候就需要开启MQ的数据持久化模式了。</li>\n<li>持久化包括三个部分： <pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 1. exchange 的持久化 \n&#x2F;&#x2F; 声明exchange 时将 durable设置为True\nch.ExchangeDeclare(\n  &quot;logs&quot;, &#x2F;&#x2F; name\n  amqp.ExchangeFanout, &#x2F;&#x2F; kind \n  true, &#x2F;&#x2F; durable\n  false, &#x2F;&#x2F; autoDelete\n  false, &#x2F;&#x2F; internal  是否为内置交换机\n  false, &#x2F;&#x2F; noWait\n  nil,   &#x2F;&#x2F; args\n)\n\n&#x2F;&#x2F; 2. queue 持久化\n&#x2F;&#x2F; 同样的在声明时 将 durable设置为True\nch.QueueDeclare(\n  &quot;hallo&quot;, &#x2F;&#x2F; name 队列名称\n  true,  &#x2F;&#x2F; durable 是否持久化\n  false, &#x2F;&#x2F; autoDelete \n  false, &#x2F;&#x2F; exclusive 排他性\n  false, &#x2F;&#x2F; noWait \n  nil, &#x2F;&#x2F; args\n)\n\n&#x2F;&#x2F; 3. message 持久化\n&#x2F;&#x2F; 发送消息时将 delivery_mode 设置为2\nch.Publish(\n  &quot;logs&quot;, &#x2F;&#x2F; exchange\n  &quot;&quot;,     &#x2F;&#x2F; routing key\n  false,  &#x2F;&#x2F; mandatory 无法路由的消息是否返回处理\n  false,  &#x2F;&#x2F; immediate 是否对路由到无消费者队列的消息进行返回处理\n  amqp.Publishing&#123;\n    ContentType: &quot;text&#x2F;plain&quot;,\n    Body:        []byte(&quot;hallo world&quot;),\n    DeliveryMode: 2,\n  &#125;,\n)</code></pre>\n\n注意：<ul>\n<li>exchange 和 queue 如果一个为持久化一个不为持久化，那么他们之间就不能进行绑定</li>\n<li>如果都为持久化，那么绑定也是持久化的</li>\n<li>设定持久化之后是不允许修改的，唯一途径是删除重建。</li>\n<li>即使你做了持久化，也还是不能完全的保证 数据不丢失，比如MQ在持久化之前挂掉了，那当时内存的数据就真的丢失了，只是这种情况的概率非常小。</li>\n<li>这一部分还可以引申出 rabbitmq 搭建高可用集群这一话题，这里就不详细讲了。简单描述一下，rmq的集群模式分为两种，一种是普通模式，比如有两个节点，那么queue只需要存在于其中一个节点即可，每个节点的数据是不同的。第二种是镜像模式，节点与节点之间会主动同步数据，这种优点和缺点都是显而易见的。反正根据自己的实际情况来选择。当然了有钱直接阿里云他不香吗。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>第三种情况就需要启用我们的ack机制了，就是当我们消费处理完毕的时候，去给mq返回一个ack确认信息。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">if msgs, err &#x3D; ch.Consume(\n  q.Name, &#x2F;&#x2F; name\n  &quot;&quot;,     &#x2F;&#x2F; consumer\n  false,   &#x2F;&#x2F; 是否自动ack\n  false,   &#x2F;&#x2F; exclusive 排他\n  false,   &#x2F;&#x2F; noLocal\n  false,   &#x2F;&#x2F; noWait\n  nil,     &#x2F;&#x2F; args\n); err !&#x3D; nil &#123;\n  log.Fatalf(&quot;获取消费队列失败:%s&quot;, err.Error())\n&#125;\n\nfor d :&#x3D; range msgs &#123;\n  &#x2F;&#x2F; 处理消息逻辑\n  if err &#x3D; d.Ack(false); err !&#x3D; nil &#123;\n    log.Printf(&quot;确认消息失败:%s&quot;, err.Error())\n  &#125;\n  log.Printf(&quot;收到消息:%s&quot;, d.Body)\n&#125;</code></pre></li>\n</ol>\n","text":"在使用消息队列的过程中如何保证消息的可靠性呢？这个问题其实包含了几方面的小问题。 数据丢失问题 数据幂等性的问题 重复消费的问题 我们知道在使用消息队列的时候是必然有三个角色的，生产者，消费者，以及MQ本身。那么数据丢失无非就以下几种情况 生产者传输给MQ 这个过程丢失数据，导致...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":1,"path":"api/categories/消息队列.json"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","count":1,"path":"api/tags/rabbitmq.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"讲明白倒排索引","uid":"e31f27ca5c997bccd8e8b4c8d00251b5","slug":"es/讲明白倒排索引","date":"2020-10-28T09:24:17.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/es/讲明白倒排索引.json","keywords":"golang rust python docker k8s","cover":[],"text":"要搞明白倒排索引我们就要先搞明白什么是正排索引 对于搜索引擎来讲，正排索引是文档id到文档内容以及单词的关联关系，也就是说通过id获取到文档的内容，如果拿关系型数据库来解释就是下面这条SQL select * from human where id &#x3D; 3; 倒排索引 ...","link":"","photos":[],"count_time":{"symbolsCount":663,"symbolsTime":"1 mins."},"categories":[{"name":"es","slug":"es","count":2,"path":"api/categories/es.json"}],"tags":[{"name":"倒排索引","slug":"倒排索引","count":1,"path":"api/tags/倒排索引.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之访问者模式","uid":"6861080263609c8f32ead8d0fe52b3fb","slug":"golang/dp/理解设计模式之访问者模式","date":"2020-10-27T08:17:55.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之访问者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"访问者模式主要是为了解决 稳定数据结构与变化的数据操作 耦合的问题。可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。 package main import &quot;fmt&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}