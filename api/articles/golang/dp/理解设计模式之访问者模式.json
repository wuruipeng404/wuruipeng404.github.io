{"title":"理解设计模式之访问者模式","uid":"6861080263609c8f32ead8d0fe52b3fb","slug":"golang/dp/理解设计模式之访问者模式","date":"2020-10-27T08:17:55.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之访问者模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>访问者模式主要是为了解决 稳定数据结构与变化的数据操作 耦合的问题。可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。<br>对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。</p>\n<span id=\"more\"></span>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 定义访问者接口\ntype IVisitor interface &#123;\n\tVisit(IElement)\n&#125;\n\n&#x2F;&#x2F; 定义生产环境访问者\ntype VisitorProduct struct &#123;\n\tname string\n&#125;\n\nfunc (c *VisitorProduct) Visit(ce IElement) &#123;\n\tfmt.Printf(&quot;%s 访问:%s&quot;, c.name, ce.Name())\n&#125;\n\n&#x2F;&#x2F; 定义测试环境访问者\ntype VisitorTesting struct &#123;\n\tname string\n&#125;\n\nfunc (c *VisitorTesting) Visit(ce IElement) &#123;\n\tfmt.Printf(&quot;%s 访问:%s&quot;, c.name, ce.Name())\n&#125;\n\n&#x2F;&#x2F; 元素接口\ntype IElement interface &#123;\n\tAccept(IVisitor)\n\tName() string\n&#125;\n\ntype ElementProduct struct &#123;\n\tname string\n&#125;\n\nfunc (c *ElementProduct) Accept(visitor IVisitor) &#123;\n\tvisitor.Visit(c)\n&#125;\n\nfunc (c *ElementProduct) Name() string &#123;\n\treturn c.name\n&#125;\n\ntype ElementTesting struct &#123;\n\tname string\n&#125;\n\nfunc (c *ElementTesting) Accept(visitor IVisitor) &#123;\n\tvisitor.Visit(c)\n&#125;\n\nfunc (c *ElementTesting) Name() string &#123;\n\treturn c.name\n&#125;\n\nfunc main() &#123;\n\tep :&#x3D; &amp;ElementProduct&#123;name: &quot;生产环境数据&quot;&#125;\n\tvp :&#x3D; &amp;VisitorProduct&#123;name: &quot;rumple&quot;&#125;\n\tep.Accept(vp)\n&#125;\n</code></pre>","text":"访问者模式主要是为了解决 稳定数据结构与变化的数据操作 耦合的问题。可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。 package main import &quot;fmt&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"关于RabbitMQ消息队列的可靠性传输","uid":"bd281a987a5c824ac404d854e69b882e","slug":"mq/关于RabbitMQ消息队列的可靠性传输","date":"2020-10-28T05:21:20.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mq/关于RabbitMQ消息队列的可靠性传输.json","keywords":"golang rust python docker k8s","cover":null,"text":"在使用消息队列的过程中如何保证消息的可靠性呢？这个问题其实包含了几方面的小问题。 数据丢失问题 数据幂等性的问题 重复消费的问题 我们知道在使用消息队列的时候是必然有三个角色的，生产者，消费者，以及MQ本身。那么数据丢失无非就以下几种情况 生产者传输给MQ 这个过程丢失数据，导致...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","count":2,"path":"api/tags/rabbitmq.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之责任链模式","uid":"4d590d0702a24ddaf8b311434285f6b8","slug":"golang/dp/理解设计模式之责任链模式","date":"2020-10-27T07:56:07.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之责任链模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"责任链模式：分离不同职责 动态的组合相关责任链责任链上的处理者负责处理请求。客户端只需要发送即可这里举一个 通俗易懂的例子，叫家人帮我买手机！ package main import &quot;fmt&quot; &#x2F;&#x2F; 定义一个购买手机的需求 type Re...","link":"","photos":[],"count_time":{"symbolsCount":872,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}