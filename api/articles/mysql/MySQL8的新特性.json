{"title":"MySQL8的新特性","uid":"c9eed3f9b00e09f8e1c1149f26ce6969","slug":"mysql/MySQL8的新特性","date":"2020-10-29T07:36:48.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL8的新特性.json","keywords":"golang rust python docker k8s","cover":[],"content":"<p>MySQL的版本一下子跳跃这么大，用手指想就有很多新的东西了。<br>下面我们就来详细了解一下。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"1-秒级加列\"><a href=\"#1-秒级加列\" class=\"headerlink\" title=\"1. 秒级加列\"></a>1. 秒级加列</h4><ol>\n<li>分别在5.7与8.0中有一张 test 表，数据为3000w行   <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"># mysql8.0.22\nmysql&gt; alter table test add str varchar(200) not null default &#39;mysql8.0 新加字段&#39;;\nQuery OK, 0 rows affected (0.13 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n# mysql5.7.30\nmysql&gt;  alter table test add str varchar(200) not null default &#39;mysql5.7 新加字段&#39;;\nQuery OK, 0 rows affected (6 min 8.36 sec)\nRecords: 0  Duplicates: 0  Warnings: 0</code></pre>\n<pre><code>可以看到 8.0 只需要 0.13 秒，而 5.7 需要 6分多钟！\n以前表加列操作需要重建表（消耗大量的IO资源和时间），8.0加列没有这个步骤。\n</code></pre>\n</li>\n</ol>\n<h4 id=\"2-性能提升\"><a href=\"#2-性能提升\" class=\"headerlink\" title=\"2. 性能提升\"></a>2. 性能提升</h4><p>   <img src=\"/images/mysql/sql8.image\" alt=\"per\"><br>   <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"># mysql5.7.30\nmysql&gt; select count(*) from test;\n+----------+\n| count(*) |\n+----------+\n| 29991137 |\n+----------+\n1 row in set (3 min 12.24 sec)\n\n# mysql8.0.22\nmysql&gt; select count(*) from test;\n+----------+\n| count(*) |\n+----------+\n| 30000000 |\n+----------+\n1 row in set (45.70 sec)</code></pre><br>    可以看到三千万的数据量，8.0版本只需要45.70秒，而5.7版本需要3分12.24秒<br>    分别在只更新和只读场景下，8.0相比5.7在高并发时性能提升近1倍；求表总数据量8.0响应时间也将近提升5倍。</p>\n<h4 id=\"3-文档数据库\"><a href=\"#3-文档数据库\" class=\"headerlink\" title=\"3. 文档数据库\"></a>3. 文档数据库</h4><ul>\n<li>MySQL Document Store，NoSQL + SQL &#x3D; MySQL</li>\n<li>多文档事务，ACID特性</li>\n<li>支持更新JSON中部分字段<br>  <img src=\"/images/mysql/sql8doc.image\" alt=\"sql8doc\"></li>\n</ul>\n<h4 id=\"4-SQL增强\"><a href=\"#4-SQL增强\" class=\"headerlink\" title=\"4. SQL增强\"></a>4. SQL增强</h4><ul>\n<li><h5 id=\"公用表表达式（CTE）\"><a href=\"#公用表表达式（CTE）\" class=\"headerlink\" title=\"公用表表达式（CTE）\"></a>公用表表达式（CTE）</h5>  关于CTE的详细介绍看这里 <a href=\"https://developer.aliyun.com/article/719994\">https://developer.aliyun.com/article/719994</a></li>\n<li><h5 id=\"不可见索引（Invisible-Indexes）\"><a href=\"#不可见索引（Invisible-Indexes）\" class=\"headerlink\" title=\"不可见索引（Invisible Indexes）\"></a>不可见索引（Invisible Indexes）</h5>将索引置为不可见时，SQL执行时查询优化器会忽略该索引；这样有助于我们了解该索引对查询语句的影响有多大。<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将索引置为不可见\nalter table test alter index  index_name invisible;\n-- 置为可见\n......................................... visible;</code></pre></li>\n<li><h5 id=\"降序索引（Descending-Indexes）\"><a href=\"#降序索引（Descending-Indexes）\" class=\"headerlink\" title=\"降序索引（Descending Indexes）\"></a>降序索引（Descending Indexes）</h5>在5.7的时候只支持升序索引，就算显式指定为降序，创建的还是升序。<br>具体例子 <a href=\"https://www.cnblogs.com/ivictor/p/9072361.html\">降序索引详解</a></li>\n<li><h5 id=\"函数索引（Functional-Indexes）\"><a href=\"#函数索引（Functional-Indexes）\" class=\"headerlink\" title=\"函数索引（Functional Indexes）\"></a>函数索引（Functional Indexes）</h5>在之前的版本中我们知道，凡是涉及到计算以及函数的都无法使用索引。 那么现在这已经是过去式了  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from test where year(date_) &#x3D; 2020;</code></pre>\n而且函数索引可以和普通索引组合为联合索引，就像普通索引与普通索引组合那样，相同的方法</li>\n</ul>\n<h4 id=\"5-默认字符集utf8mb4\"><a href=\"#5-默认字符集utf8mb4\" class=\"headerlink\" title=\"5. 默认字符集utf8mb4\"></a>5. 默认字符集utf8mb4</h4>  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql root@localhost:(none)&gt; show variables like &#39;%character%&#39;;\n+--------------------------+--------------------------------+\n| Variable_name            | Value                          |\n+--------------------------+--------------------------------+\n| character_set_client     | utf8                           |\n| character_set_connection | utf8                           |\n| character_set_database   | utf8mb4                        |\n| character_set_filesystem | binary                         |\n| character_set_results    | utf8                           |\n| character_set_server     | utf8mb4                        |\n| character_set_system     | utf8                           |\n| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql-8.0&#x2F;charsets&#x2F; |\n+--------------------------+--------------------------------+\n8 rows in set\nTime: 0.028s</code></pre>\n<ul>\n<li>可以更好的存储emojis</li>\n<li>可变长度编码字符的性能提升<br>  <img src=\"/images/mysql/sql8char.image\" alt=\"char\"></li>\n</ul>\n<h4 id=\"6-一致性查询改进\"><a href=\"#6-一致性查询改进\" class=\"headerlink\" title=\"6. 一致性查询改进\"></a>6. 一致性查询改进</h4><ul>\n<li><p>SKIP LOCKED<br>需要加锁的记录若被其它线程占有锁，则跳过，而不是等待</p>\n  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from test where age&#x3D;12 for update skip locked;\nEmpty set (0.00 sec)</code></pre>\n</li>\n<li><p>NOWAIT<br>需要加锁的记录如果有锁，则会报错</p>\n  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from test where age&#x3D;12 for update nowait;\nERROR 3572 (HY000): Statement aborted because lock(s) could not be acquired immediately and NOWAIT is set.</code></pre>\n<p>  这两个特性某种意义上替代了redis的作用。</p>\n</li>\n</ul>\n<h4 id=\"7-资源组\"><a href=\"#7-资源组\" class=\"headerlink\" title=\"7. 资源组\"></a>7. 资源组</h4><ul>\n<li>线程赋给不同的资源组</li>\n<li>资源组和不同的内存、IO、CPU(现仅支持)进行关联<br>  <img src=\"/images/mysql/sql8source.image\" alt=\"source\"></li>\n</ul>\n<h4 id=\"8-新的数据字典\"><a href=\"#8-新的数据字典\" class=\"headerlink\" title=\"8. 新的数据字典\"></a>8. 新的数据字典</h4><ul>\n<li>基于innodb的库表元数据信息</li>\n<li>增强了MySQL crash-safe能力</li>\n<li>原子DDL（ Atomic DDLs ）<br>  <img src=\"/images/mysql/sql8dict.image\" alt=\"dict\"><br>  以前版本MySQL数据字典存放在多个地方，一机器多实例时存在大量文件描述符性能消耗。</li>\n</ul>\n<p>  8.0版本都存放在事务性InnoDB表，MySQL异常挂掉后也不会再出现表损坏情况；DDL操作失败也不会再留下占空间的<code>临时文件</code></p>\n<h4 id=\"9-MGR-增强\"><a href=\"#9-MGR-增强\" class=\"headerlink\" title=\"9. MGR 增强\"></a>9. MGR 增强</h4><ul>\n<li>金融级别99.999%官方高可用方案</li>\n<li>MGR是业务多活(应用多活+数据库多活)的终极方案</li>\n<li>多个MySQL组成一个group，数据写group</li>\n<li>线上10套多主8.0 MGR集群<br>  <img src=\"/images/mysql/sql8mgr.image\" alt=\"mgr\"><br>  MGR的增强大大提升了在网络异常(机房级故障)下的健壮、稳定性</li>\n</ul>\n<h4 id=\"10-安全性增强\"><a href=\"#10-安全性增强\" class=\"headerlink\" title=\"10. 安全性增强\"></a>10. 安全性增强</h4>  <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># SQL角色\nSQL Roles      \n# 原子ACL语句\nAtomic ACL Statements       \n# 动态特权\nDynamic Privileges          \n# 防止暴力攻击\nProtection Against Brute Force Attacks     \n# REDO &amp; UNDO Logs加密\nREDO &amp; UNDO Logs Encryption        \n# 缓存Sa2认证插件\nCaching sha2 authentication plugin     \n# 密码轮询策略\nPassword Rotation Policy        </code></pre>\n\n<h4 id=\"11-复制增强\"><a href=\"#11-复制增强\" class=\"headerlink\" title=\"11. 复制增强\"></a>11. 复制增强</h4>  <pre class=\"line-numbers language-py\" data-language=\"py\"><code class=\"language-py\"># binlog中额外的Metadata\nAdditional Metadata in the binary log      \n\n# 高效的json复制 \nEfficient JSON Replication \n\n# 监控复制延迟细到毫秒\nMonitor Replication Lag with Microsecond Precision \n\n# 组复制更多的P_S\nMore P_S Instrumentation for Group Replication \n\n# 默认启动了binlog\nEnable binary log by default   \n\n# 基于Writeset-based Dependency Tracking的并行应用\nImproving the Parallel Applier with Writeset-based Dependency Tracking \n\n# 组复制白名单中支持主机名\nHostname support in Group Replication Whitelist    </code></pre>\n\n<h4 id=\"12-实例克隆\"><a href=\"#12-实例克隆\" class=\"headerlink\" title=\"12. 实例克隆\"></a>12. 实例克隆</h4><ul>\n<li>以前都是要备份恢复，再加入主从复制</li>\n<li>现在可以在原目标实例上直接安装克隆插件 授权进行克隆</li>\n</ul>\n<h4 id=\"13-全局变量持久化\"><a href=\"#13-全局变量持久化\" class=\"headerlink\" title=\"13. 全局变量持久化\"></a>13. 全局变量持久化</h4><p>  以前我们在客户端执行MySQL配置，都是暂时性的，MySQL重启后就会失效。想永久设置只能修改配置文件。8.0版本直接通过SQL命令，就可以直接永久配置。</p>\n<ul>\n<li><code>set persist</code><br>会在设置当前全局变量的前提下，将其保存到 mysqld-auto.cnf 文件中，这个命令需要有这个权限：system_variables_admin，才能执行</li>\n<li><code>set persist_only</code><br>只会将其保存到 mysqld-auto.cnf 文件中，而不会设置当前全局变量，这对只读全局变量有用，这个命令需要有这个权限：persist_ro_variables_admin，才能执行</li>\n</ul>\n<h4 id=\"14-其他\"><a href=\"#14-其他\" class=\"headerlink\" title=\"14. 其他\"></a>14. 其他</h4><ul>\n<li>优化器直方图</li>\n<li>自增主键持久化</li>\n<li>移除Query Cache</li>\n<li>GIS增强</li>\n<li>备份锁</li>\n<li>group by 不再隐式排序</li>\n<li>redo_log优化、多线程并发写log buffer</li>\n</ul>\n","text":"MySQL的版本一下子跳跃这么大，用手指想就有很多新的东西了。下面我们就来详细了解一下。 1. 秒级加列 分别在5.7与8.0中有一张 test 表，数据为3000w行 # mysql8.0.22 mysql&gt; alter table test add str varcha...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%A7%92%E7%BA%A7%E5%8A%A0%E5%88%97\"><span class=\"toc-text\">1. 秒级加列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">2. 性能提升</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">3. 文档数据库</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-SQL%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">4. SQL增强</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88CTE%EF%BC%89\"><span class=\"toc-text\">公用表表达式（CTE）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%B4%A2%E5%BC%95%EF%BC%88Invisible-Indexes%EF%BC%89\"><span class=\"toc-text\">不可见索引（Invisible Indexes）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95%EF%BC%88Descending-Indexes%EF%BC%89\"><span class=\"toc-text\">降序索引（Descending Indexes）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%B4%A2%E5%BC%95%EF%BC%88Functional-Indexes%EF%BC%89\"><span class=\"toc-text\">函数索引（Functional Indexes）</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86utf8mb4\"><span class=\"toc-text\">5. 默认字符集utf8mb4</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E4%B8%80%E8%87%B4%E6%80%A7%E6%9F%A5%E8%AF%A2%E6%94%B9%E8%BF%9B\"><span class=\"toc-text\">6. 一致性查询改进</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E8%B5%84%E6%BA%90%E7%BB%84\"><span class=\"toc-text\">7. 资源组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">8. 新的数据字典</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-MGR-%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">9. MGR 增强</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E5%AE%89%E5%85%A8%E6%80%A7%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">10. 安全性增强</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E5%A4%8D%E5%88%B6%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">11. 复制增强</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E5%AE%9E%E4%BE%8B%E5%85%8B%E9%9A%86\"><span class=\"toc-text\">12. 实例克隆</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">13. 全局变量持久化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#14-%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">14. 其他</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构之线性与非线性","uid":"80648934d5c19eeef307e3bc1f9a947e","slug":"ds/数据结构之线性与非线性","date":"2020-10-30T02:35:58.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/ds/数据结构之线性与非线性.json","keywords":"golang rust python docker k8s","cover":[],"text":"数据结构是计算机存储组织数据的方式，常见的数据结构分类如下图： 线性结构 什么是线性结构？ 数据结构中线性结构指的是数据元素之间存在着 一对一 的线性关系的数据结构。线性结构是一个有序数据元素的集合。 线性结构的特点- 线性结构有唯一的首元素（第一个元素）- 线性结构有唯一的尾元...","link":"","photos":[],"count_time":{"symbolsCount":597,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"讲明白倒排索引","uid":"e31f27ca5c997bccd8e8b4c8d00251b5","slug":"es/讲明白倒排索引","date":"2020-10-28T09:24:17.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/es/讲明白倒排索引.json","keywords":"golang rust python docker k8s","cover":[],"text":"要搞明白倒排索引我们就要先搞明白什么是正排索引 对于搜索引擎来讲，正排索引是文档id到文档内容以及单词的关联关系，也就是说通过id获取到文档的内容，如果拿关系型数据库来解释就是下面这条SQL select * from human where id &#x3D; 3; 倒排索引 ...","link":"","photos":[],"count_time":{"symbolsCount":663,"symbolsTime":"1 mins."},"categories":[{"name":"es","slug":"es","count":2,"path":"api/categories/es.json"}],"tags":[{"name":"倒排索引","slug":"倒排索引","count":1,"path":"api/tags/倒排索引.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}