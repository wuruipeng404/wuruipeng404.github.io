{"title":"python调用rust与go生成的库文件","uid":"9675eb8263b3ddc03bf1d31763c2e083","slug":"rust/python-rust-go","date":"2020-11-11T03:09:44.000Z","updated":"2021-12-11T02:10:04.781Z","comments":true,"path":"api/articles/rust/python-rust-go.json","keywords":"golang rust python docker k8s","cover":[],"content":"<h3 id=\"Python-Rust-Go-我最喜欢的三门语言。\"><a href=\"#Python-Rust-Go-我最喜欢的三门语言。\" class=\"headerlink\" title=\"Python,Rust,Go 我最喜欢的三门语言。\"></a>Python,Rust,Go 我最喜欢的三门语言。</h3><p>  今天来搞一下 分别用rust&amp;&amp;go生成<code>.so</code>文件供python调用，顺便简单测试一下他们之间的性能差距</p>\n<h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><ul>\n<li>Python: 3.8.6</li>\n<li>Go: 1.15.3</li>\n<li>Rust: 1.49.0-nightly (25f6938da 2020-11-09)</li>\n</ul>\n<span id=\"more\"></span>\n<h4 id=\"1-Rust\"><a href=\"#1-Rust\" class=\"headerlink\" title=\"1. Rust\"></a>1. Rust</h4><ol>\n<li>编写python能用的库文件，我们需要用到<a href=\"https://github.com/PyO3/pyo3\">pyo3</a>这个项目（其实不用也可以，但是会比较吃藕，pyo3可以直接包装成python的数据类型,以及python的module。而且pyo3的功能不止如此）<ol>\n<li>安装<br> rust版本分为 stable, beta 和 nightly 版本，pyo3目前需要使用nightly版本，所以我们先安装 nightly <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">rustup install nightly\n# 如果已经安装过则升级\nrustup update nightly\n\n# 切换\nrustup default nightly</code></pre></li>\n<li>修改<code>.cargo</code>配置文件 <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">vim ~&#x2F;.cargo&#x2F;config</code></pre>\n 填入如下内容 <pre class=\"line-numbers language-config\" data-language=\"config\"><code class=\"language-config\">[target.x86_64-apple-darwin]\nrustflags &#x3D; [\n  &quot;-C&quot;, &quot;link-arg&#x3D;-undefined&quot;,\n  &quot;-C&quot;, &quot;link-arg&#x3D;dynamic_lookup&quot;,\n]</code></pre></li>\n</ol>\n</li>\n<li>创建项目  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cargo new r2py</code></pre></li>\n</ol>\n<ul>\n<li>创建好后目录下会有一个<code>Cargo.toml</code>文件，内容如下  <pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">[package]\nname &#x3D; &quot;r2py&quot;\nversion &#x3D; &quot;0.1.0&quot;\nauthors &#x3D; [&quot;rumple&quot;]\nedition &#x3D; &quot;2018&quot;\n\n[dependencies]\n\n# 以下为手动添加依赖与配置部分\n[lib]\nname &#x3D; &quot;r2py&quot;\ncrate-type &#x3D; [&quot;cdylib&quot;]\n\n[dependencies.pyo3]\nversion &#x3D; &quot;*&quot;\nfeatures &#x3D; [&quot;extension-module&quot;]</code></pre></li>\n</ul>\n<ol start=\"3\">\n<li>编写库文件<br>   在src下创建<code>lib.rs</code>文件,我们来创建一个计算函数  <pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\">use pyo3::prelude::*;\nuse pyo3::wrap_pyfunction;\n\n\n#[pyfunction]\nfn add(num: u64) -&gt; PyResult&lt;u64&gt; &#123;\n    let mut sum &#x3D; 0;\n\n    for i in 0..&#x3D;num &#123;\n        sum +&#x3D; i;\n    &#125;\n    Ok(sum)\n&#125;\n\n#[pymodule]\nfn r2p(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123;\n    m.add_wrapped(wrap_pyfunction!(add))?;\n    Ok(())\n&#125;</code></pre></li>\n<li>编译：<code>cargo build --release</code><br>编译后会在src同级目录生成 <code>target/release/libr2py.dylib</code>,你也可以直接指定cargo配置文件中的crate-type去直接生成so文件，不过这里是一样的。</li>\n<li>把文件拷贝到我们的python测试目录待用。  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cp target&#x2F;release&#x2F;libr2py.dylib  $&#123;yourdirectory&#125;&#x2F;r2py.so</code></pre></li>\n</ol>\n<h4 id=\"2-Go\"><a href=\"#2-Go\" class=\"headerlink\" title=\"2. Go\"></a>2. Go</h4><ul>\n<li><p>编写 <code>libadd.go</code></p>\n  <pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;C&quot;\n\n&#x2F;&#x2F;export add\nfunc add(num uint64) uint64 &#123;\n\n  var (\n    i, sum uint64   \n  )\n\n  for i &lt; num &#123;\n    i++\n    sum +&#x3D; i\n &#125;\n  return sum\n&#125;\n\nfunc main()  &#123;\n  \n&#125;</code></pre>\n</li>\n<li><p>编译</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">go build -buildmode&#x3D;c-shared -o libadd.so libadd.go</code></pre></li>\n</ul>\n<h4 id=\"3-编写Python测试脚本\"><a href=\"#3-编写Python测试脚本\" class=\"headerlink\" title=\"3. 编写Python测试脚本\"></a>3. 编写Python测试脚本</h4>  <pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\nimport r2py # pyo3的好处。可以直接当做module导入\n\nfrom ctypes import cdll, c_ulonglong\n\ngo_lib &#x3D; cdll.LoadLibrary(&quot;.&#x2F;src&#x2F;libadd.so&quot;)\n# 处理数据类型 不然会溢出\ngo_add &#x3D; go_lib.add\ngo_add.restype &#x3D; c_ulonglong\n\n\nNUM_CONST &#x3D; 1000000000\n\n\ndef time_decorator(func):\n    def wrap():\n        start &#x3D; time.process_time()\n        a &#x3D; func()\n        end &#x3D; time.process_time()\n        print(f&quot;cost:&#123;end - start&#125; seconds&quot;)\n        return a\n\n    return wrap\n\n\n@time_decorator\ndef py_test():\n    s &#x3D; 0\n    for i in range(NUM_CONST + 1):\n        s +&#x3D; i\n    return s\n\n\n@time_decorator\ndef rust_test():\n    return r2py.add(NUM_CONST)\n\n\n@time_decorator\ndef go_test():\n    return go_add(NUM_CONST)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    print(&quot;&#x3D;&quot; * 50)\n    print(f&quot;python 结果:&#123;py_test()&#125;&quot;)\n\n    print(&quot;&#x3D;&quot; * 50)\n    print(f&quot;rust 结果:&#123;rust_test()&#125;&quot;)\n\n    print(&quot;&#x3D;&quot; * 50)\n    print(f&quot;go 结果:&#123;go_test()&#125;&quot;)</code></pre>\n\n<h4 id=\"4-结果\"><a href=\"#4-结果\" class=\"headerlink\" title=\"4.结果\"></a>4.结果</h4><p><img src=\"/images/rust/rgp.png\" alt=\"result\"></p>\n<p>结果显而易见啦，不过这里让我惊奇的是 go 竟然比 rust 还要快一点，golang 牛逼。<br>当然啦这里只是一个很简单的计算场景，孰强孰弱还需要更多不同场景的探索,而且他们所适用的方向可能也不太一样。<br>但rust毕竟是号称新时代的底层语言，我觉得潜力还是很大的。</p>\n","text":"Python,Rust,Go 我最喜欢的三门语言。 今天来搞一下 分别用rust&amp;&amp;go生成.so文件供python调用，顺便简单测试一下他们之间的性能差距 版本 Python: 3.8.6 Go: 1.15.3 Rust: 1.49.0-nightly (25f...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"rust","slug":"rust","count":1,"path":"api/categories/rust.json"}],"tags":[{"name":"go","slug":"go","count":4,"path":"api/tags/go.json"},{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"},{"name":"rust","slug":"rust","count":1,"path":"api/tags/rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Python-Rust-Go-%E6%88%91%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E9%97%A8%E8%AF%AD%E8%A8%80%E3%80%82\"><span class=\"toc-text\">Python,Rust,Go 我最喜欢的三门语言。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">版本</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Rust\"><span class=\"toc-text\">1. Rust</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Go\"><span class=\"toc-text\">2. Go</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BC%96%E5%86%99Python%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">3. 编写Python测试脚本</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">4.结果</span></a></li></ol></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"MySQL之MVCC","uid":"94d8fb994bc3cd6f390288bebd2dcdbe","slug":"mysql/MySQL之MVCC","date":"2020-11-11T09:46:56.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL之MVCC.json","keywords":"golang rust python docker k8s","cover":null,"text":"什么是MVCC？ 英文全称为Multi-Version Concurrency Control,即多版本并发控制。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。 原理 MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"github-ssh协议配置代理","uid":"357905e1891b1f51272b4c207482f185","slug":"guide/github-ssh协议配置代理","date":"2020-11-10T07:10:01.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/github-ssh协议配置代理.json","keywords":"golang rust python docker k8s","cover":null,"text":"最近git连github经常抽风 使用 git config --global http.proxy的方式也没用的状态下，就想搞一下ssh协议走代理开搞 配置 .ssh/config Host github.com ProxyCommand ~&#x2F;.ssh&#x2F;ss...","link":"","photos":[],"count_time":{"symbolsCount":493,"symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"git","slug":"git","count":2,"path":"api/tags/git.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}