{"name":"设计模式","slug":"设计模式","count":24,"postlist":[{"title":"理解设计模式之中介者模式","uid":"2f29c37507db5ca2a228334b44c7a06a","slug":"golang/dp/理解设计模式之中介者模式","date":"2020-10-26T09:39:55.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之中介者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"中介者模式是用来封装对象与对象之间的交互，使依赖变简单，使复杂交互简单化，封装在中介者中，显而易见的缺点就是，由于逻辑封装在中介者中，所以中介者以后会越来越复杂 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义中介者类 typ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之享元模式","uid":"0e88d00be424e9da6d7f13b5a9de850e","slug":"golang/dp/理解设计模式之享元模式","date":"2020-10-26T06:22:51.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之享元模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"享元模式是指：从对象中剥离出不发生改变且多个实例都需要的重复数据（当然这个数据也可以是对象），独立出一个享元，从而减少对象的创建，节省内存 package main import &quot;fmt&quot; type ImageFactory struct &#123; ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之代理模式","uid":"0cc18532576f0420deb16181e5056f24","slug":"golang/dp/理解设计模式之代理模式","date":"2020-10-26T03:26:47.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之代理模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"代理模式用于延迟处理操作或者在进行实际操作前后进行其它处理。 package main import &quot;fmt&quot; type Work interface &#123; Do() string &#125; type RealWork struct&#123;&...","link":"","photos":[],"count_time":{"symbolsCount":708,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之单例模式","uid":"1602c992a6a28c4ed33dd66720a6bf2e","slug":"golang/dp/理解设计模式之单例模式","date":"2020-10-23T12:05:12.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之单例模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"go语言中的单例模式简单到没啥可说的。 正常创建一个全局变量就是，单例为了线程安全你可以加锁，这里直接使用sync.once,原理一样。 go package main import &quot;sync&quot; type Singleton struct&#123;&#12...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之原型模式","uid":"ff7986bd3e13e58f395ae3555d928c50","slug":"golang/dp/理解设计模式之原型模式","date":"2020-10-23T12:08:31.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之原型模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"原型模式和其他创建型模式不一样的是，它是复制一个已有对象，而不是创建一个新对象，被复制的对象就叫做原型。原型模式多用于建造复杂或者耗时的对象，这样直接复制会比较高效。原型对象一般会配合原型管理器一起使用 go package main import ( &quot;fmt&quo...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之命令模式","uid":"2f495e9970023abb3de380eead14299f","slug":"golang/dp/理解设计模式之命令模式","date":"2020-10-26T10:05:50.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之命令模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。 示例中把主板单中的启动(start)方法和重启(reboot)方法封装为命令对象，再传递到主机(box)对象中。于两个按钮进行绑定： 第一个机箱(box1)设置按钮1(buttion1) 为开机按钮2(but...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之外观模式","uid":"9b3ae101f06841603467d83a4a546e9c","slug":"golang/dp/理解设计模式之外观模式","date":"2020-10-26T02:52:42.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之外观模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"外观模式的主要作用是 减少客户端与系统内部交互的复杂性，对子系统的一系列接口，提供一个一致性的界面，方便调用 package main import &quot;fmt&quot; func NewAPI() FacadeAPI &#123; return &amp;apiImp...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之备忘录模式","uid":"31a528ce1cc912e617e7cd21630fdad9","slug":"golang/dp/理解设计模式之备忘录模式","date":"2020-10-27T07:08:52.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之备忘录模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"备忘录，字面意思，一般会用来保存程序快照。或者 将内部程序的状态暴露给 外部，而不展示具体细节 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义备忘录接口 type Memo interface &#123; Save() M...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之工厂方法模式","uid":"ac7a60db5b9b5c38555c42db8dd8bf35","slug":"golang/dp/理解设计模式之工厂方法模式","date":"2020-10-23T09:40:20.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之工厂方法模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"与简单工厂不同，简单工厂 &#x3D; 一个工厂创造所有的 类对象，如果此对象在工厂中没有，就只能修改代码 去新增对象的创造过程而工厂方法 则只是定义了一系列的接口， 定义创建对象的接口，定义工厂的接口，具体的工厂对象，以及 产品 对象 都由外部自己实现。 相当于只是定义了规则 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"},{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之建造者模式","uid":"c3aea0285a3783cfb28818d4df287ed0","slug":"golang/dp/理解设计模式之建造者模式","date":"2020-10-23T11:05:37.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之建造者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"建造者模式主要作用是解耦了创建的过程,将一个复杂对象的创建过程分步完成.下面来讲两种风格的建造者模式 gopackage main import &quot;fmt&quot; &#x2F;&#x2F; 1.传统类型: 由指挥者指挥建造者创建具体的对象 &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之桥接模式","uid":"4e7dab327a16c4ff4445f675a754b4bd","slug":"golang/dp/理解设计模式之桥接模式","date":"2020-10-26T06:54:02.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之桥接模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"桥接模式分离抽象部分和实现部分。使得两部分可以独立扩展。 package main import &quot;fmt&quot; &#x2F;&#x2F; 抽象消息接口 定义具体的消息类型 type AbsMessage interface &#123; SendMessage(...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之抽象工厂","uid":"c1243241d6dbe40f7f47b73a2a79fbcc","slug":"golang/dp/理解设计模式之抽象工厂","date":"2020-10-23T10:54:34.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之抽象工厂.json","keywords":"golang rust python docker k8s","cover":null,"text":"抽象工厂 是在工厂方法的基础之上进化而来，其中最大的不同点是：工厂方法模式中的工厂 只创建一种对象，而抽象工厂中的工厂 则是创建多种对象，而往往这些对象是有关联的，一个家族的一系列对象，比如 订单和订单详情 go &#x2F;&#x2F; 订单信息接口 type Order in...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之模板方法模式","uid":"047033f0c1450db28daf35058b5fd01e","slug":"golang/dp/理解设计模式之模板方法模式","date":"2020-10-27T02:23:35.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之模板方法模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"模版方法模式使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则。注意匿名组合虽然像继承，但还是有不一样的地方的。比如，因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用 package main impor...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之策略模式","uid":"8edf5cc3c2cccf16484400f87c198799","slug":"golang/dp/理解设计模式之策略模式","date":"2020-10-27T06:51:40.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之策略模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"策略模式一般是用来封装一系列的算法，让这些算法可以在运行时互换。复合开闭原则 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义付款对象 type Payment struct &#123; context *PaymentCo...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之简单工厂","uid":"66121ee3bb53d4eaf9b18fd8c88d13c8","slug":"golang/dp/理解设计模式之简单工厂","date":"2020-10-23T09:27:12.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之简单工厂.json","keywords":"golang rust python docker k8s","cover":null,"text":"所谓简单工厂是指 用来封装一个类对象的具体创建细节，去构造一个对象在go语言中没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。 package factory impor...","link":"","photos":[],"count_time":{"symbolsCount":687,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"},{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之状态模式","uid":"57343b3b347c194726d5fcd7c1e57903","slug":"golang/dp/理解设计模式之状态模式","date":"2020-10-27T06:58:29.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之状态模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"状态模式没啥好说的，就是用来分离行为与状态的。直接看例子 package main import &quot;fmt&quot; type Week interface &#123; Today() Next(*DayContext) &#125; type DayContext...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之组合模式","uid":"ae24c711008000da26e897d1dea4a2e7","slug":"golang/dp/理解设计模式之组合模式","date":"2020-10-26T05:37:01.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之组合模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"组合模式可以统一对象以及对象集，之后可以使用相同接口去访问这些对象和对象集组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。 这里咱们就直接创建一个树。 package main import ( &quot;log&quot; ) &...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之解释器模式","uid":"f06ad8235feac5c0bb5f9c61b04ab4af","slug":"golang/dp/理解设计模式之解释器模式","date":"2020-10-27T07:28:27.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之解释器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。 package main import &qu...","link":"","photos":[],"count_time":{"symbolsCount":821,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之访问者模式","uid":"6861080263609c8f32ead8d0fe52b3fb","slug":"golang/dp/理解设计模式之访问者模式","date":"2020-10-27T08:17:55.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之访问者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"访问者模式主要是为了解决 稳定数据结构与变化的数据操作 耦合的问题。可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。 package main import &quot;fmt&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之责任链模式","uid":"4d590d0702a24ddaf8b311434285f6b8","slug":"golang/dp/理解设计模式之责任链模式","date":"2020-10-27T07:56:07.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之责任链模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"责任链模式：分离不同职责 动态的组合相关责任链责任链上的处理者负责处理请求。客户端只需要发送即可这里举一个 通俗易懂的例子，叫家人帮我买手机！ package main import &quot;fmt&quot; &#x2F;&#x2F; 定义一个购买手机的需求 type Re...","link":"","photos":[],"count_time":{"symbolsCount":872,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之观察者模式","uid":"53fbeba8ed5d161cf25f38b1905c9c66","slug":"golang/dp/理解设计模式之观察者模式","date":"2020-10-26T09:55:25.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之观察者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"观察者模式比较好理解，就是字面意思，其实和发布订阅差不多。举一个学生订阅课程的例子 package main &#x2F;&#x2F; 定义课程接口 type ISubject interface &#123; Attach(IObserver) &#x2F;&#x2F; 添加观...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之装饰器模式","uid":"f0bac87a6e91ff11c8f0bc84046165ce","slug":"golang/dp/理解设计模式之装饰器模式","date":"2020-10-26T06:38:34.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之装饰器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"熟悉python的朋友对装饰器肯定不陌生，他的定义就是在不改变原有定义的情况下，动态的添加功能。这里的装饰器模式其实也是一个意思 首先来看一个最简单的,在go中函数是一等公民，所以是可以当成参数传递的，那么这就简单了。 func pprint() &#123; fmt.Print...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之迭代器模式","uid":"293d39b9d616d2268ed47b9219110ea6","slug":"golang/dp/理解设计模式之迭代器模式","date":"2020-10-27T01:35:19.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之迭代器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"迭代器模式，一样的一个字面意思，封装你的对象 对外提供一个迭代器，可以不断迭代你的对象，这样外部无需了解对象的具体实现细节，通过迭代器就可以不断访问下一个元素 package main import &quot;container&#x2F;list&quot; &#x2F;&#...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之适配器模式","uid":"81dbbf6776f0e83a5de64679463cd385","slug":"golang/dp/理解设计模式之适配器模式","date":"2020-10-26T03:20:15.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之适配器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"适配器模式用于转换一种接口适配另一种接口。 package main import &quot;fmt&quot; &#x2F;&#x2F; Target 是适配的目标接口 type Target interface &#123; Request() string &#125; ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}]}