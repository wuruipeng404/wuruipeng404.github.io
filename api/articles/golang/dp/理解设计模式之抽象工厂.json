{"title":"理解设计模式之抽象工厂","uid":"c1243241d6dbe40f7f47b73a2a79fbcc","slug":"golang/dp/理解设计模式之抽象工厂","date":"2020-10-23T10:54:34.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之抽象工厂.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>抽象工厂 是在工厂方法的基础之上进化而来，其中最大的不同点是：<br>工厂方法模式中的工厂 只创建一种对象，而抽象工厂中的工厂 则是创建多种对象，而往往这些对象是有关联的，一个家族的一系列对象，比如  订单和订单详情</p>\n<span id=\"more\"></span>\n<ol>\n<li><p>go</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 订单信息接口\ntype Order interface &#123;\n\tSaveOrderInfo()\n&#125;\n\n&#x2F;&#x2F; 订单详情接口\ntype OrderDetail interface &#123;\n\tSaveOrderDetailInfo()\n&#125;\n\n&#x2F;&#x2F; Order 抽象模式工厂接口\ntype OrderFactory interface &#123;\n\tCreateOrder() Order\n\tCreateOrderDetail() OrderDetail\n&#125;\n\n&#x2F;&#x2F; ------------------------------------------------------\n&#x2F;&#x2F; 我们实现分别用数据库存储订单信息 以及 文件存储订单信息\ntype DBOrderSaver struct&#123;&#125;\n\nfunc (*DBOrderSaver) SaveOrderInfo() &#123;\n\tfmt.Println(&quot;保存订单到数据库&quot;)\n&#125;\n\n&#x2F;&#x2F; 订单详情\ntype DBOrderDetailSaver struct&#123;&#125;\n\nfunc (*DBOrderDetailSaver) SaveOrderDetailInfo() &#123;\n\tfmt.Println(&quot;保存订单详情到数据库&quot;)\n&#125;\n\n&#x2F;&#x2F; 创建数据库 订单相关系列对象的工厂\ntype DBOrderFactory struct&#123;&#125;\n\nfunc (*DBOrderFactory) CreateOrder() Order &#123;\n\treturn &amp;DBOrderSaver&#123;&#125;\n&#125;\n\nfunc (*DBOrderFactory) CreateOrderDetail() OrderDetail &#123;\n\treturn &amp;DBOrderDetailSaver&#123;&#125;\n&#125;\n\n&#x2F;&#x2F; file\ntype FileOrderSaver struct&#123;&#125;\n\nfunc (*FileOrderSaver) SaveOrderInfo() &#123;\n\tfmt.Println(&quot;保存订单到文件&quot;)\n&#125;\n\ntype FileOrderDetailSaver struct&#123;&#125;\n\nfunc (*FileOrderDetailSaver) SaveOrderDetailInfo() &#123;\n\tfmt.Println(&quot;保存订单详情到文件&quot;)\n&#125;\n\ntype FileOrderFactory struct&#123;&#125;\n\nfunc (*FileOrderFactory) CreateOrder() Order &#123;\n\treturn &amp;FileOrderSaver&#123;&#125;\n&#125;\n\nfunc (*FileOrderFactory) CreateOrderDetail() OrderDetail &#123;\n\treturn &amp;FileOrderDetailSaver&#123;&#125;\n&#125;\n\nfunc main() &#123;\n\tdbf :&#x3D; &amp;DBOrderFactory&#123;&#125;\n\torder :&#x3D; dbf.CreateOrder()\n\torderDet :&#x3D; dbf.CreateOrderDetail()\n\n\torder.SaveOrderInfo()\n\torderDet.SaveOrderDetailInfo()\n&#125;</code></pre>\n</li>\n<li><p>python</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import abc\n\n\nclass SomeThing(object):\n\n    def __init__(self, brand: str):\n        self.brand &#x3D; brand\n\n    @abc.abstractmethod\n    def fly(self):\n        pass\n\n    @abc.abstractmethod\n    def run(self):\n        pass\n\n\nclass Plane(SomeThing):\n\n    def __init__(self, *args, **kwargs):\n        super(Plane, self).__init__(*args, **kwargs)\n\n    def fly(self):\n        print(f&quot;&#123;self.brand&#125; &#123;Plane.__name__&#125; i can fly&quot;)\n\n    def run(self):\n        print(f&quot;&#123;self.brand&#125; &#123;Plane.__name__&#125; i also run&quot;)\n\n\nclass Tank(SomeThing):\n\n    def __init__(self, *args, **kwargs):\n        super(Tank, self).__init__(*args, **kwargs)\n\n    def fly(self):\n        print(f&quot;&#123;self.brand&#125; &#123;Tank.__name__&#125; i can&#39;t fly&quot;)\n\n    def run(self):\n        print(f&quot;&#123;self.brand&#125; &#123;Tank.__name__&#125; i can run&quot;)\n\n\nclass Factory(object):\n    &quot;&quot;&quot;\n    工厂基类\n    &quot;&quot;&quot;\n\n    @abc.abstractmethod\n    def create_plane(self):\n        pass\n\n    @abc.abstractmethod\n    def create_tank(self):\n        pass\n\n\nclass SamsungFactory(Factory):\n    brand &#x3D; &quot;samsung&quot;\n\n    def create_plane(self):\n        return Plane(SamsungFactory.brand)\n\n    def create_tank(self):\n        return Tank(SamsungFactory.brand)\n\n\nclass AppleFactory(Factory):\n    brand &#x3D; &quot;apple&quot;\n\n    def create_plane(self):\n        return Plane(AppleFactory.brand)\n\n    def create_tank(self):\n        return Tank(AppleFactory.brand)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    samsung_factory &#x3D; SamsungFactory()\n    samsung_plane &#x3D; samsung_factory.create_plane()\n    samsung_tank &#x3D; samsung_factory.create_tank()\n\n    samsung_tank.fly()\n    samsung_tank.run()\n\n    samsung_plane.fly()\n    samsung_plane.run()\n\n    apple_factory &#x3D; AppleFactory()\n    # ...</code></pre></li>\n</ol>\n","text":"抽象工厂 是在工厂方法的基础之上进化而来，其中最大的不同点是：工厂方法模式中的工厂 只创建一种对象，而抽象工厂中的工厂 则是创建多种对象，而往往这些对象是有关联的，一个家族的一系列对象，比如 订单和订单详情 go &#x2F;&#x2F; 订单信息接口 type Order in...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"理解设计模式之建造者模式","uid":"c3aea0285a3783cfb28818d4df287ed0","slug":"golang/dp/理解设计模式之建造者模式","date":"2020-10-23T11:05:37.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之建造者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"建造者模式主要作用是解耦了创建的过程,将一个复杂对象的创建过程分步完成.下面来讲两种风格的建造者模式 gopackage main import &quot;fmt&quot; &#x2F;&#x2F; 1.传统类型: 由指挥者指挥建造者创建具体的对象 &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之工厂方法模式","uid":"ac7a60db5b9b5c38555c42db8dd8bf35","slug":"golang/dp/理解设计模式之工厂方法模式","date":"2020-10-23T09:40:20.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之工厂方法模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"与简单工厂不同，简单工厂 &#x3D; 一个工厂创造所有的 类对象，如果此对象在工厂中没有，就只能修改代码 去新增对象的创造过程而工厂方法 则只是定义了一系列的接口， 定义创建对象的接口，定义工厂的接口，具体的工厂对象，以及 产品 对象 都由外部自己实现。 相当于只是定义了规则 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"},{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}