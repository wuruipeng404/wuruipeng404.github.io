{"title":"理解设计模式之组合模式","uid":"ae24c711008000da26e897d1dea4a2e7","slug":"golang/dp/理解设计模式之组合模式","date":"2020-10-26T05:37:01.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之组合模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>组合模式可以统一对象以及对象集，之后可以使用相同接口去访问这些对象和对象集<br>组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。</p>\n<p>这里咱们就直接创建一个树。</p>\n<span id=\"more\"></span>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;log&quot;\n)\n\n&#x2F;&#x2F; 定义基础对象接口 树 组件的基本属性\ntype TreeComponent interface &#123;\n\tParent() TreeComponent   &#x2F;&#x2F; 获取父节点\n\tSetParent(TreeComponent) &#x2F;&#x2F; 设置父节点\n\tName() string            &#x2F;&#x2F; 名称\n\tSetName(string)          &#x2F;&#x2F; 设置名称\n\tAddChild(TreeComponent)  &#x2F;&#x2F; 添加子节点\n\tCount() int              &#x2F;&#x2F; 查看当前节点的子节点数量\n&#125;\n\nfunc NewTreeComponent(kind int, name string) TreeComponent &#123;\n\n\tvar c TreeComponent\n\tlog.Print(&quot;创建节点&quot;)\n\tif kind &#x3D;&#x3D; 0 &#123;\n\t\tc &#x3D; NewLeaf(name)\n\t&#125; else &#123;\n\t\tc &#x3D; NewNonLeaf(name)\n\t&#125;\n\treturn c\n&#125;\n\n&#x2F;&#x2F; ----------叶子节点-----------\ntype Leaf struct &#123;\n\tname   string\n\tparent TreeComponent\n&#125;\n\n&#x2F;&#x2F; 构造函数\nfunc NewLeaf(name string) *Leaf &#123;\n\treturn &amp;Leaf&#123;name: name&#125;\n&#125;\n\nfunc (l *Leaf) Parent() TreeComponent &#123;\n\treturn l.parent\n&#125;\n\nfunc (l *Leaf) SetParent(component TreeComponent) &#123;\n\tl.parent &#x3D; component\n&#125;\n\nfunc (l *Leaf) Name() string &#123;\n\treturn l.name\n&#125;\n\nfunc (l *Leaf) SetName(name string) &#123;\n\tl.name &#x3D; name\n&#125;\n\n&#x2F;&#x2F; 叶子节点不能添加子节点 所以这里什么都不做\nfunc (l *Leaf) AddChild(component TreeComponent) &#123;\n\n&#125;\n\nfunc (l *Leaf) Count() int &#123;\n\treturn 1\n&#125;\n\n&#x2F;&#x2F; ----- 非叶子节点------\ntype NonLeaf struct &#123;\n\tname     string\n\tparent   TreeComponent\n\tchildren []TreeComponent\n&#125;\n\nfunc NewNonLeaf(name string) *NonLeaf &#123;\n\treturn &amp;NonLeaf&#123;\n\t\tchildren: make([]TreeComponent, 0),\n\t\tname:     name,\n\t&#125;\n&#125;\n\nfunc (n *NonLeaf) Parent() TreeComponent &#123;\n\treturn n.parent\n&#125;\n\nfunc (n *NonLeaf) SetParent(component TreeComponent) &#123;\n\tn.parent &#x3D; component\n&#125;\n\nfunc (n *NonLeaf) Name() string &#123;\n\treturn n.name\n&#125;\n\nfunc (n *NonLeaf) SetName(name string) &#123;\n\tn.name &#x3D; name\n&#125;\n\nfunc (n *NonLeaf) AddChild(component TreeComponent) &#123;\n\tlog.Println(&quot;添加子节点&quot;, component.Name())\n\tcomponent.SetParent(n)\n\tn.children &#x3D; append(n.children, component)\n&#125;\n\nfunc (n *NonLeaf) Count() int &#123;\n\tlog.Println(&quot;获取所有子节点数量&quot;)\n\n\tvar count &#x3D; 1 &#x2F;&#x2F; 注意: 把自己算进去,所以这里是1\n\tfor _, x :&#x3D; range n.children &#123;\n\t\tcount +&#x3D; x.Count()\n\t&#125;\n\treturn count\n&#125;\n\nfunc main() &#123;\n\n\t&#x2F;&#x2F; 创建根节点\n\trootNode :&#x3D; NewTreeComponent(1, &quot;root&quot;)\n\n\t&#x2F;&#x2F; 循环十次 每次 给root节点添加一个 叶子节点 和 非叶子节点, 非叶子节点也添加一个 叶子节点\n\tfor i :&#x3D; 0; i &lt;&#x3D; 10; i++ &#123;\n\t\trootNode.AddChild(NewTreeComponent(0, &quot;leaf&quot;))\n\t\tnf :&#x3D; NewTreeComponent(1, &quot;nonLeaf&quot;)\n\t\tnf.AddChild(NewTreeComponent(0, &quot;leaf&quot;))\n\t\trootNode.AddChild(nf)\n\t&#125;\n\n\tlog.Println(rootNode.Count())\n&#125;</code></pre>","text":"组合模式可以统一对象以及对象集，之后可以使用相同接口去访问这些对象和对象集组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。 这里咱们就直接创建一个树。 package main import ( &quot;log&quot; ) &...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"理解设计模式之享元模式","uid":"0e88d00be424e9da6d7f13b5a9de850e","slug":"golang/dp/理解设计模式之享元模式","date":"2020-10-26T06:22:51.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之享元模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"享元模式是指：从对象中剥离出不发生改变且多个实例都需要的重复数据（当然这个数据也可以是对象），独立出一个享元，从而减少对象的创建，节省内存 package main import &quot;fmt&quot; type ImageFactory struct &#123; ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之代理模式","uid":"0cc18532576f0420deb16181e5056f24","slug":"golang/dp/理解设计模式之代理模式","date":"2020-10-26T03:26:47.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之代理模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"代理模式用于延迟处理操作或者在进行实际操作前后进行其它处理。 package main import &quot;fmt&quot; type Work interface &#123; Do() string &#125; type RealWork struct&#123;&...","link":"","photos":[],"count_time":{"symbolsCount":708,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}