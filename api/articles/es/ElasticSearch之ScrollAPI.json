{"title":"ElasticSearch之ScrollAPI","uid":"a96d6d6139d5419f25b0435643fa218f","slug":"es/ElasticSearch之ScrollAPI","date":"2020-10-16T07:07:23.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/es/ElasticSearch之ScrollAPI.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>&amp;#160;&amp;#160;&amp;#160;&amp;#160;最近遇到了一个需求，公司集团的所有项目日志都是存在kafka中，通过logstash去不断读取，通过一定的规则将日志切割为我们需要的格式，存入ES。我们要做的就是定期不断的从ES中取获取日志，分析日志。</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><h4 id=\"Scroll的概念\"><a href=\"#Scroll的概念\" class=\"headerlink\" title=\"Scroll的概念\"></a>Scroll的概念</h4><p> Scroll其实和文件读取中的指针(seek)，传统数据库中的游标非常相似，目的是为了在数据量特别大的时候，去检索数据。因为不可能在一次请求中将所有数据一并处理。</p>\n</li>\n<li><h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><p> ES检索数据所使用的api使用GET,POST方法都是可以的，query <code>scroll</code> 的意思是表明此次会话的有效时长是多久，如果过期的话ES会自动销毁，不过在实际使用过程中，最好还是使用完毕后主动销毁,因为保存会话的存活是有成本的。DSL查询条件则存放于body中</p>\n<ul>\n<li>首次查询 <pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">POST &#x2F;index&#x2F;_search?scroll&#x3D;1m\n&#123;\n  &quot;size&quot;:1000,\n  &quot;query&quot;:&#123;\n    &quot;range&quot;:&#123;\n      &quot;timestamp&quot;:&#123;\n        &quot;gt&quot;:&quot;xxxxx&quot;,  # 我这里是检索一定时间范围的数据，注意，这里的时间是UTC格式的时间字符串\n        &quot;lt&quot;:&quot;xxxxx&quot;,\n      &#125;\n    &#125;\n  &#125;\n&#125;\n</code></pre></li>\n<li>在此次请求结果中，除了会得到正常的search response外，还会得到一个 _scroll_id ，而我们后续的请求就会使用这个id去请求scroll api，直到hits中的数据长度为0.</li>\n</ul>\n <pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">POST &#x2F;_search&#x2F;scroll\n# 注意 scroll 请求url中不能包含 index 和 type，因为初始请求已经包含。（type 在es7以后已经不再推荐使用了）\n&#123;\n  &quot;scroll&quot;: &quot;1m&quot;, # 让此次会话再保存1分钟\n  &quot;scroll_id&quot;: [_scroll_id] # 首次请求所的到的id\n&#125;</code></pre>\n<ul>\n<li>销毁会话 可以在query中传入scroll_id 也可以在body中 <pre class=\"line-numbers language-none\"><code class=\"language-none\">DELETE &#x2F;_search&#x2F;id1,id2\n&#123;\n  &quot;scroll_id&quot;: &quot;xxxxx&quot;,\n  # 也可以使用数组传递多个\n  &quot;scroll_id&quot;: [\n    &quot;id1&quot;,\n    &quot;id2&quot;\n  ]\n&#125;\n\n# 也可以一次性删除所有\nDELETE &#x2F;_search&#x2F;scroll&#x2F;_all</code></pre></li>\n</ul>\n</li>\n<li><h4 id=\"完成需求代码\"><a href=\"#完成需求代码\" class=\"headerlink\" title=\"完成需求代码\"></a>完成需求代码</h4>  <pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">import (\n  &quot;logs&quot;\n  &quot;context&quot;\n  &quot;fmt&quot;\n  requests &quot;github.com&#x2F;levigross&#x2F;grequests&quot;\n  &quot;time&quot;\n)\n\ntype (\n  searchBody struct &#123;\n    Query _query &#96;json:&quot;query&quot;&#96;\n    Size  int    &#96;json:&quot;size&quot;&#96;\n  &#125;\n\n  _query struct &#123;\n    Range _range &#96;json:&quot;range&quot;&#96;\n  &#125;\n\n  _range struct &#123;\n    Timestamp _timestamp &#96;json:&quot;timestamp&quot;&#96;\n  &#125;\n\n  _timestamp struct &#123;\n    Gte string &#96;json:&quot;gte&quot;&#96;\n    Lte string &#96;json:&quot;lte&quot;&#96;\n  &#125;\n\n  searchResult struct &#123;\n    ScrollId string &#96;json:&quot;_scroll_id&quot;&#96;\n    Hits     _hits  &#96;json:&quot;hits&quot;&#96;\n  &#125;\n\n  _hits struct &#123;\n    Hits []map[string]interface&#123;&#125; &#96;json:&quot;hits&quot;&#96;\n  &#125;\n)\n\nfunc job(ctx context.Context) &#123;\n  var (\n    err   error\n    index string\n    resp  *requests.Response\n  )\n\n  const (\n    utcFormat  &#x3D; &quot;2006-01-02T15:04:05Z&quot;\n    searchSize &#x3D; 1000\n    scroll     &#x3D; &quot;10m&quot;\n  )\n\n  now :&#x3D; time.Now()\n  start :&#x3D; now.Add(-time.Hour)\n\n  gte :&#x3D; start.Format(utcFormat)\n  lte :&#x3D; now.Format(utcFormat)\n\n  body :&#x3D; searchBody&#123;\n    Query: _query&#123;_range&#123;_timestamp&#123;\n      Gte: gte,\n      Lte: lte,\n    &#125;&#125;&#125;,\n    Size: searchSize,\n  &#125;\n\n  defer func() &#123;\n    _ &#x3D; resp.Close()\n  &#125;()\n\n  if resp, err &#x3D; requests.Get(fmt.Sprintf(&quot;http:&#x2F;&#x2F;%s&#x2F;%s&#x2F;_search?scroll&#x3D;%s&quot;, esHost, index, scroll),\n    &amp;requests.RequestOptions&#123;\n      Context: ctx,\n      Auth:    []string&#123;esUser, esPass&#125;,\n      JSON:    body,\n    &#125;); err !&#x3D; nil &#123;\n    logs.Errorf(err.Error())\n    return\n  &#125;\n\n  var (\n    serRes searchResult\n    tmp    []map[string]interface&#123;&#125;\n  )\n\n  if err &#x3D; resp.JSON(&amp;serRes); err !&#x3D; nil &#123;\n    logs.Errorf(&quot;解析json失败:%s&quot;, err.Error())\n    return\n  &#125;\n\n  tmp &#x3D; append(tmp, serRes.Hits.Hits...)\n\n  defer func() &#123;\n    &#x2F;&#x2F; 清除会话\n    if dResp, err :&#x3D; requests.Delete(fmt.Sprintf(&quot;http:&#x2F;&#x2F;%s&#x2F;_search&#x2F;scroll&#x2F;%s&quot;, esHost, serRes.ScrollId),\n      &amp;requests.RequestOptions&#123;Auth: []string&#123;esUser, esPass&#125;&#125;); err !&#x3D; nil &#123;\n      logs.Errorf(&quot;清楚scroll会话失败:%s&quot;, err.Error())\n    &#125; else &#123;\n      _ &#x3D; dResp.Close()\n    &#125;\n  &#125;()\n\n  for &#123;\n    var er searchResult\n    if resp, err &#x3D; requests.Get(fmt.Sprintf(&quot;http:&#x2F;&#x2F;%s&#x2F;_search&#x2F;scroll&quot;, esHost),\n      &amp;requests.RequestOptions&#123;\n        Context: ctx,\n        Auth:    []string&#123;esUser, esPass&#125;,\n        JSON: map[string]interface&#123;&#125;&#123;\n          &quot;scroll&quot;:    scroll,\n          &quot;scroll_id&quot;: serRes.ScrollId,\n        &#125;,\n      &#125;); err !&#x3D; nil &#123;\n      logs.Errorf(&quot;scroll error : %s&quot;, err.Error())\n      return\n    &#125;\n\n    if err &#x3D; resp.JSON(&amp;er); err !&#x3D; nil &#123;\n      logs.Errorf(&quot;scroll json error : %s&quot;, err.Error())\n      return\n    &#125;\n\n    if len(er.Hits.Hits) &#x3D;&#x3D; 0 &#123;\n      break\n    &#125;\n\n    tmp &#x3D; append(tmp, er.Hits.Hits...)\n  &#125;\n\n  logs.Infof(&quot;最终结果:%s&quot;, tmp)\n&#125;</code></pre></li>\n</ol>\n","text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;最近遇到了一个需求，公司集团的所有项目日志都是存在kafka中，通过logstash去不断读取，通过一定的规则将日志切割为我们需要的格式，存入ES。我们要做的就是定期不断的从ES中取获取日志，分析日志...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"es","slug":"es","count":2,"path":"api/categories/es.json"}],"tags":[{"name":"es","slug":"es","count":1,"path":"api/tags/es.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Scroll%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Scroll的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基本使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%88%90%E9%9C%80%E6%B1%82%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完成需求代码</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"Golang程序实现自动更新","uid":"26beaec8904420e53dae414f48ef2055","slug":"golang/Golang程序实现自动更新","date":"2020-10-16T08:03:06.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/Golang程序实现自动更新.json","keywords":"golang rust python docker k8s","cover":null,"text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;我们都知道一个正常的golang程序部署流程大致都要经过编译，测试，发布(人工或者自动化) ，在大公司基础设施完善，当然也未必。我现在就身处于一个上市公司，但是基础建设极其惨不忍睹的公司。扯远了。进入...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"go","slug":"go","count":4,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"工欲善其事, 必先利其器","uid":"8a8f9d1afc1722a111bba925b4b1caf6","slug":"config/工欲善其事","date":"2020-10-14T08:58:32.000Z","updated":"2022-03-12T12:54:34.081Z","comments":true,"path":"api/articles/config/工欲善其事.json","keywords":"golang rust python docker k8s","cover":[],"text":"俗话说的好，工欲善其事必先利其器，作为一名有追求的开发者，当然要将自己吃饭的家伙打造的即好用又美观啦。 接下来我主要会从 系统软件与配置 , Chrome插件 , Terminal 三个方面去推荐好用的软件及配置 系统软件与配置篇 系统软件 name description Al...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"工具配置","slug":"工具配置","count":1,"path":"api/categories/工具配置.json"}],"tags":[{"name":"mac","slug":"mac","count":1,"path":"api/tags/mac.json"},{"name":"config","slug":"config","count":1,"path":"api/tags/config.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}