{"title":"关于消息队列的常见问题","uid":"d4819b7b42636665ecebcade56925532","slug":"mq/关于消息队列的常见问题","date":"2020-11-13T02:31:17.000Z","updated":"2022-03-13T04:40:34.550Z","comments":true,"path":"api/articles/mq/关于消息队列的常见问题.json","keywords":"golang rust python docker k8s","cover":null,"content":"<h3 id=\"1-如何确保消息正确地发送至RabbitMQ？\"><a href=\"#1-如何确保消息正确地发送至RabbitMQ？\" class=\"headerlink\" title=\"1. 如何确保消息正确地发送至RabbitMQ？\"></a>1. 如何确保消息正确地发送至RabbitMQ？</h3><p>RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。</p>\n<p>发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。</p>\n<p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">channel.confirm_delivery()</code></pre>\n\n<h3 id=\"2-如何确保消息接收方消费了消息？\"><a href=\"#2-如何确保消息接收方消费了消息？\" class=\"headerlink\" title=\"2. 如何确保消息接收方消费了消息？\"></a>2. 如何确保消息接收方消费了消息？</h3><p>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。</p>\n<p>这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。</p>\n<p>下面罗列几种特殊情况：</p>\n<ul>\n<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）</li>\n<li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</li>\n</ul>\n<h3 id=\"3-如何避免消息重复投递或重复消费？\"><a href=\"#3-如何避免消息重复投递或重复消费？\" class=\"headerlink\" title=\"3. 如何避免消息重复投递或重复消费？\"></a>3. 如何避免消息重复投递或重复消费？</h3><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；</p>\n<p>在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</p>\n<h3 id=\"4-消息基于什么传输？\"><a href=\"#4-消息基于什么传输？\" class=\"headerlink\" title=\"4. 消息基于什么传输？\"></a>4. 消息基于什么传输？</h3><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>\n<h3 id=\"5-消息如何分发？\"><a href=\"#5-消息如何分发？\" class=\"headerlink\" title=\"5. 消息如何分发？\"></a>5. 消息如何分发？</h3><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p>\n<h3 id=\"6-消息怎么路由？\"><a href=\"#6-消息怎么路由？\" class=\"headerlink\" title=\"6. 消息怎么路由？\"></a>6. 消息怎么路由？</h3><p>从概念上来说，消息路由必须有三部分：<strong>交换器</strong>、<strong>路由</strong>、<strong>绑定</strong>。生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。</p>\n<ol>\n<li>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。</li>\n<li>通过队列路由键，可以把队列绑定到交换器上。</li>\n<li>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。</li>\n</ol>\n<p>常用的交换器主要分为一下三种：</p>\n<ul>\n<li><code>direct</code>：如果路由键完全匹配，消息就被投递到相应的队列</li>\n<li><code>fanout</code>：如果交换器收到消息，将会广播到所有绑定的队列上</li>\n<li><code>topic</code>：可以使来自不同源头的消息能够到达同一个队列。 使用<code>topic</code>交换器时，可以使用通配符，比如：“*” 匹配特定位置的任意文本， “.” 把路由键分为了几部分，“#” 匹配所有规则等。特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由”.”隔开的一系列的标识符组成。</li>\n</ul>\n<h3 id=\"7-如何确保消息不丢失？\"><a href=\"#7-如何确保消息不丢失？\" class=\"headerlink\" title=\"7. 如何确保消息不丢失？\"></a>7. 如何确保消息不丢失？</h3><p>消息持久化的前提是：将交换器&#x2F;队列的<code>durable</code>属性设置为<code>true</code>，表示交换器&#x2F;队列是持久交换器&#x2F;队列，在服务器崩溃或重启之后不需要重新创建交换器&#x2F;队列（交换器&#x2F;队列会自动创建）。</p>\n<p>如果消息想要从Rabbit崩溃中恢复，那么消息必须：</p>\n<ul>\n<li>在消息发布前，通过把它的 “投递模式” 选项设置为2（持久）来把消息标记成持久化</li>\n<li>将消息发送到持久交换器</li>\n<li>消息到达持久队列</li>\n</ul>\n<p>RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应（如果消息路由到了非持久队列，它会自动从持久化日志中移除）。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列（以及绑定），并重播持久化日志文件中的消息到合适的队列或者交换器上。</p>\n<h3 id=\"8-使用RabbitMQ有什么好处？\"><a href=\"#8-使用RabbitMQ有什么好处？\" class=\"headerlink\" title=\"8. 使用RabbitMQ有什么好处？\"></a>8. 使用RabbitMQ有什么好处？</h3><ul>\n<li>应用解耦（系统拆分）</li>\n<li>异步处理（预约挂号业务处理成功后，异步发送短信、推送消息、日志记录等）</li>\n<li>消息分发</li>\n<li>流量削峰</li>\n<li>消息缓冲</li>\n<li>……</li>\n</ul>\n","text":"1. 如何确保消息正确地发送至RabbitMQ？RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。 发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","count":2,"path":"api/tags/rabbitmq.json"},{"name":"mq","slug":"mq","count":1,"path":"api/tags/mq.json"},{"name":"消息队列","slug":"消息队列","count":1,"path":"api/tags/消息队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%8F%91%E9%80%81%E8%87%B3RabbitMQ%EF%BC%9F\"><span class=\"toc-text\">1. 如何确保消息正确地发送至RabbitMQ？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E6%96%B9%E6%B6%88%E8%B4%B9%E4%BA%86%E6%B6%88%E6%81%AF%EF%BC%9F\"><span class=\"toc-text\">2. 如何确保消息接收方消费了消息？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%8A%95%E9%80%92%E6%88%96%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F\"><span class=\"toc-text\">3. 如何避免消息重复投递或重复消费？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%B6%88%E6%81%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E4%BC%A0%E8%BE%93%EF%BC%9F\"><span class=\"toc-text\">4. 消息基于什么传输？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%B6%88%E6%81%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%8F%91%EF%BC%9F\"><span class=\"toc-text\">5. 消息如何分发？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E8%B7%AF%E7%94%B1%EF%BC%9F\"><span class=\"toc-text\">6. 消息怎么路由？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F\"><span class=\"toc-text\">7. 如何确保消息不丢失？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BD%BF%E7%94%A8RabbitMQ%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F\"><span class=\"toc-text\">8. 使用RabbitMQ有什么好处？</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"查看日志相关的命令","uid":"517d2648b07f96d72267ed192f3c0c92","slug":"guide/查看日志相关的命令","date":"2020-11-18T07:38:28.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/查看日志相关的命令.json","keywords":"golang rust python docker k8s","cover":null,"text":"作为一名开发，查询过滤日志去debug 应该是基本功中的基本功了。今天详细介绍一下这些命令 1. head head 与 tail 是一对命令，从字面意思也可以看出其作用 head 是用来查看头部的内容，tail 用来查看尾部的内容 参数： - -q 隐藏文件名 - -v 显示文...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":6,"path":"api/categories/操作指南.json"}],"tags":[{"name":"head","slug":"head","count":1,"path":"api/tags/head.json"},{"name":"grep","slug":"grep","count":1,"path":"api/tags/grep.json"},{"name":"tail","slug":"tail","count":1,"path":"api/tags/tail.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"MySQL之MVCC","uid":"94d8fb994bc3cd6f390288bebd2dcdbe","slug":"mysql/MySQL之MVCC","date":"2020-11-11T09:46:56.000Z","updated":"2022-03-13T05:29:53.248Z","comments":true,"path":"api/articles/mysql/MySQL之MVCC.json","keywords":"golang rust python docker k8s","cover":null,"text":"什么是MVCC？ 英文全称为Multi-Version Concurrency Control,即多版本并发控制。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。 原理 MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"mysql","slug":"mysql","count":4,"path":"api/categories/mysql.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}