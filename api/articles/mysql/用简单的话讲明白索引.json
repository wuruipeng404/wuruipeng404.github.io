{"title":"用简单的话讲明白MySQL索引","uid":"5a2cdee73626da8985a23805f627ad4f","slug":"mysql/用简单的话讲明白索引","date":"2020-10-20T01:57:21.000Z","updated":"2022-03-13T05:29:44.930Z","comments":true,"path":"api/articles/mysql/用简单的话讲明白索引.json","keywords":"golang rust python docker k8s","cover":[],"content":"<h3 id=\"索引的作用\"><a href=\"#索引的作用\" class=\"headerlink\" title=\"索引的作用\"></a>索引的作用</h3><pre><code>顾名思义，索引其实就是字面意思，和我们以前查字典的索引是一样的意思，能够帮助我们快速的查找到相关数据，这就是索引，哈希表的键，人的名字，工号，身份证号，这些都是索引\n</code></pre>\n<h3 id=\"BTree-B-Tree\"><a href=\"#BTree-B-Tree\" class=\"headerlink\" title=\"BTree(B-Tree)\"></a>BTree(B-Tree)</h3><p>  B树和B-树其实是一个意思。它长这个样子<br>  <img src=\"/images/mysql/BTree.png\" alt=\"BTree\"></p>\n<span id=\"more\"></span>\n<p>  它是一颗多路平衡查找树，我们描述一颗B树时需要指定它的阶数，阶数表示一个节点最多有多少个子节点，一般用<code>m</code>表示，当<code>m</code>取2时，就是常见的二叉树。<br>  特性：</p>\n<ul>\n<li>节点从左到右递增排序</li>\n<li>每个数据节点后面都会紧跟着一个指针，该指针是指向下一级的内存地址。下一级指的是位于当前指针左右两边数值中间的数据记录所存在内存中的地址。</li>\n<li>叶子节点 的指针为空</li>\n<li>所有索引元素是不重复的。</li>\n<li>每个索引节点都存着当前指向的记录数据或内存地址</li>\n</ul>\n<h3 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h3><p>  B+树是B树的一个变种，它在B树的基础之上做了一些改善，将索引节点所关联的数据记录全部移到了叶子节点上，目的是为了可以存储更多的索引节点，但是却增加了索引节点的冗余，因为叶子节点包含了所有的索引节点。<br>  <img src=\"/images/mysql/B+Tree.png\" alt=\"B+Tree\"><br>  特性：</p>\n<ul>\n<li>叶子节点包含所有的索引节点 </li>\n<li>非叶子节点不存储数据记录 </li>\n<li>叶子节点之间使用指针连接，提高区间访问的便利 </li>\n<li>指针所指向的索引节点的最左边都是大于等于指针所在深度左边的值</li>\n</ul>\n<h3 id=\"MySQL中的B-Tree\"><a href=\"#MySQL中的B-Tree\" class=\"headerlink\" title=\"MySQL中的B+Tree\"></a>MySQL中的B+Tree</h3><p>  <img src=\"/images/mysql/MB+Tree.png\" alt=\"MB+Tre\"><br>  MySQL所使用的B+Tree是对于B+Tree更进一步的优化</p>\n<ul>\n<li>增加了一个双向的指针 </li>\n<li>首尾节点也通过指针进行关联起来 主要目的是为了更加友好的支持索引内部的范围查找。如果不加双向链表指针，我们每次查找的时候，都要回到根节点查找，增加了磁盘IO，增加查询时间。</li>\n</ul>\n<h3 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h3><p>  聚簇索引：索引文件与数据存放在一起<br>  非聚簇索引：索引文件与数据文件分开存放<br>  我们知道MySQL支持很多存储引擎，InnoDB,MyISAM,Memory等等，我们最常用的也是MySQL默认的就是InnoDB。<br>  虽然InnoDB与MyISAM都是用B+树作为索引的存储结构，但在MyISAM中叶子节点是不存储数据的，而是数据存放的地址，这种就叫做非聚簇索引，而InnoDB叶子节点是存放完整数据的。</p>\n<h3 id=\"本篇主要讨论的是InnoDB引擎，MyISAM有兴趣可以自己查阅相关资料\"><a href=\"#本篇主要讨论的是InnoDB引擎，MyISAM有兴趣可以自己查阅相关资料\" class=\"headerlink\" title=\"本篇主要讨论的是InnoDB引擎，MyISAM有兴趣可以自己查阅相关资料\"></a>本篇主要讨论的是InnoDB引擎，MyISAM有兴趣可以自己查阅相关资料</h3><h3 id=\"主键索引与非主键索引\"><a href=\"#主键索引与非主键索引\" class=\"headerlink\" title=\"\b主键索引与非主键索引\"></a>\b主键索引与非主键索引</h3><p>  在InnoDB中主键索引的叶子节点存储的是当前关联的整条记录，而非主键索引（辅助索引，二级索引）叶子节点存储的是主键值。也就是说当你使用二级索引去搜索数据，其实是要查询两次的，首先查询到对应的主键值，再通过主键值去查询数据，这个操作有个专业词语叫做<code>回行</code>。</p>\n<h3 id=\"为什么必须要有主键，而且是自增的int型\"><a href=\"#为什么必须要有主键，而且是自增的int型\" class=\"headerlink\" title=\"为什么必须要有主键，而且是自增的int型\"></a>为什么必须要有主键，而且是自增的int型</h3><ul>\n<li>为什么Innodb表必须有主键?<br>在innodb存储引擎表中，mysql会给主键添加聚集索引，如果没有主键，mysql则会选举表中设置了唯一索引的字段设置为主键，创建主键索引；如果表中没有字段设置为唯一索引，则mysql会生成一个6字节的row_id，作为主键，创建主键索引。</li>\n<li>为什么mysql推荐使用整形作为主键字段类型？<br>在组建B树的时候，mysql会按照从小到大的顺序进行组建，如果是整形数字的话，mysql则可以直接进行比较，如果是其它类型的话，mysql还得需要将值转换为ascill码，进行比较，会增加创建索引和查询的时间。</li>\n<li>为什么要求是自增类型？<br>在聚集索引中叶子节点存储数据的其实是数据页，也就是多行数据组成一个页，一页通常大小为16K。假设主键是不规则的UUID，当你插入数据时，为了保持B+Tree的平衡，会造成频繁的页分裂和页旋转，大大影响操作效率。而自增的int型时，数据插入只需要不断往右边扩充即可</li>\n</ul>\n<h3 id=\"为什么非主键索引结构叶子节点存储的是主键值\"><a href=\"#为什么非主键索引结构叶子节点存储的是主键值\" class=\"headerlink\" title=\"为什么非主键索引结构叶子节点存储的是主键值\"></a>为什么非主键索引结构叶子节点存储的是主键值</h3><ul>\n<li>如果存储的是具体的数据的话，会造成数据不一致的问题，因为主键索引和辅助索引会同时维护数据记录，如果有一方维护失败则会出现不一致性的问题</li>\n<li>都存储具体数据的话，会造成存储空间的浪费，如果只存储主键记录的话，可以存储更多的索引记录，但是需要二次根据主键查找具体数据，以时间换空间</li>\n</ul>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p>  首先我们创建一张表方便说明<br>  <img src=\"/images/mysql/table.png\" alt=\"table\"><br>  id 为自增主键，有主键索引<br>  username为二级索引。</p>\n<ul>\n<li>用不到覆盖索引，需要回行  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from users where username&#x3D;&quot;zhangsan&quot;;</code></pre></li>\n<li>覆盖索引，不需要回行  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select id from users where username&#x3D;&quot;zhangsan&quot;;</code></pre></li>\n</ul>\n<p>  相信聪明的你，已经知道覆盖索引是什么意思了。简单来说就是我们所需要的数据在索引叶上已经有了，不需要再去查询主键回行进行查询。<br>  如何尽可能的用到覆盖索引呢？这就引出了我们的下一话题，联合索引。</p>\n<h3 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h3><p>  所谓联合索引，就是将多个字段联合为一个索引。好处就是，这样更符合实际需求，减少维护单个索引的成本，如果你只是为每一个字段建立了一个普通的二级索引，那么维护这些索引的成本是巨大的，而且实际的情况也不可能是只用某一个字段作为条件搜索对吧。<br>  同时联合索引的另一个优点就是 一个联合索引 基本可以覆盖很多所需情况<br>  比如说上表 我建立一个 <code>(username,gender,age)</code>的联合索引，当你使用 username ,或者 username,gender,或者username,gender,age都可以使用到这个索引文件，这个描述其实引出了众所周知的 最左前缀原则。</p>\n<h3 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h3><p>  就和我们读书看字一样，数据库根据索引去查找数据也是从左往右读，这就是所谓的最左前缀原则。<br>  <img src=\"/images/mysql/left_index.png\" alt=\"left_index\"><br>  如图所示是 (<code>username</code>,<code>age</code>) 的联合索引数据结构<br>  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select id from users where username like &quot;张%&quot;;\nselect id from users where username&#x3D;&quot;张三&quot; and age&#x3D;14;</code></pre><br>  以上这些都是可以使用到索引的。<br>  到这里相信你大概知道你的索引该怎样优化了，以及联合索引该怎样重建，顺序等等。</p>\n<p>  tips:<br>    在老版本的mysql中，索引使用的顺序是要严格按照 索引建立时的顺序去使用的。而现在完全不需要操心这个事情啦。mysql会自动把我们的语句优化成可以使用索引的样子。</p>\n","text":"索引的作用顾名思义，索引其实就是字面意思，和我们以前查字典的索引是一样的意思，能够帮助我们快速的查找到相关数据，这就是索引，哈希表的键，人的名字，工号，身份证号，这些都是索引 BTree(B-Tree) B树和B-树其实是一个意思。它长这个样子 它是一颗多路平衡查找树，我们描述一...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"mysql","slug":"mysql","count":4,"path":"api/categories/mysql.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"数据库索引","slug":"数据库索引","count":1,"path":"api/tags/数据库索引.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">索引的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BTree-B-Tree\"><span class=\"toc-text\">BTree(B-Tree)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-Tree\"><span class=\"toc-text\">B+Tree</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MySQL%E4%B8%AD%E7%9A%84B-Tree\"><span class=\"toc-text\">MySQL中的B+Tree</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">聚簇索引与非聚簇索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E7%AF%87%E4%B8%BB%E8%A6%81%E8%AE%A8%E8%AE%BA%E7%9A%84%E6%98%AFInnoDB%E5%BC%95%E6%93%8E%EF%BC%8CMyISAM%E6%9C%89%E5%85%B4%E8%B6%A3%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E6%9F%A5%E9%98%85%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99\"><span class=\"toc-text\">本篇主要讨论的是InnoDB引擎，MyISAM有兴趣可以自己查阅相关资料</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">\b主键索引与非主键索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E4%B8%BB%E9%94%AE%EF%BC%8C%E8%80%8C%E4%B8%94%E6%98%AF%E8%87%AA%E5%A2%9E%E7%9A%84int%E5%9E%8B\"><span class=\"toc-text\">为什么必须要有主键，而且是自增的int型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E4%B8%BB%E9%94%AE%E5%80%BC\"><span class=\"toc-text\">为什么非主键索引结构叶子节点存储的是主键值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">覆盖索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">联合索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">最左前缀原则</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"DockerSwarm搭建完整的微服务项目","uid":"27852f8dc79cc34a496b7be5ae32dae9","slug":"golang/DockerSwarm搭建完整的微服务项目","date":"2020-10-20T06:59:52.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/DockerSwarm搭建完整的微服务项目.json","keywords":"golang rust python docker k8s","cover":null,"text":"这是一个容器化快速发展的时代，相信不少朋友都已经体会到了容器的便利性，自从我第一眼看到容器这个东西，就对其深深的爱上了。也确定了我以后的职业发展方向。这也是我喜欢Golang的原因 最近接到一个说大不大说下不小的项目，因为K8S有点太重了，我们人员资源有限，所以这一次我打算用do...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"docker","slug":"docker","count":2,"path":"api/categories/docker.json"}],"tags":[{"name":"docker","slug":"docker","count":2,"path":"api/tags/docker.json"},{"name":"swarm","slug":"swarm","count":1,"path":"api/tags/swarm.json"},{"name":"架构","slug":"架构","count":1,"path":"api/tags/架构.json"},{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"Golang程序Dockerfile最佳实践","uid":"e68c644f0327c9651998fad434541edf","slug":"docker/Golang程序Dockerfile最佳实践","date":"2020-10-16T08:51:49.000Z","updated":"2022-03-13T05:31:05.835Z","comments":true,"path":"api/articles/docker/Golang程序Dockerfile最佳实践.json","keywords":"golang rust python docker k8s","cover":[],"text":"众所周知，通过Dockerfile去构建镜像是分层执行的，\b如何使我们的镜像最小化，以及不会泄露源代码等，我总结一个比较通用的Dockerfile. FROM golang:latest as builder WORKDIR &#x2F;home&#x2F;works&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"docker","slug":"docker","count":2,"path":"api/categories/docker.json"},{"name":"go","slug":"docker/go","count":1,"path":"api/categories/docker/go.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"},{"name":"docker","slug":"docker","count":2,"path":"api/tags/docker.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}