{"title":"MySQL之MVCC","uid":"94d8fb994bc3cd6f390288bebd2dcdbe","slug":"mysql/MySQL之MVCC","date":"2020-11-11T09:46:56.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL之MVCC.json","keywords":"golang rust python docker k8s","cover":null,"content":"<h3 id=\"什么是MVCC？\"><a href=\"#什么是MVCC？\" class=\"headerlink\" title=\"什么是MVCC？\"></a>什么是MVCC？</h3><p>  英文全称为Multi-Version Concurrency Control,即<strong>多版本并发控制</strong>。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>  MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p>\n<ul>\n<li>每行数据都存在一个版本，每次数据更新时都会更新该版本。</li>\n<li>修改时Copy出当前版本随意修改，各个事务之间无干扰。</li>\n<li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）<span id=\"more\"></span>\n<h3 id=\"InnoDB的MVCC实现策略\"><a href=\"#InnoDB的MVCC实现策略\" class=\"headerlink\" title=\"InnoDB的MVCC实现策略\"></a>InnoDB的MVCC实现策略</h3>  在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。<br>  每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目。</li>\n</ul>\n<h3 id=\"通过示例来看看是如何工作的\"><a href=\"#通过示例来看看是如何工作的\" class=\"headerlink\" title=\"通过示例来看看是如何工作的\"></a>通过示例来看看是如何工作的</h3><ol>\n<li><p>假如我们有这样一张表</p>\n  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">create table users (id int primary key not null auto_increment, name varchar(255) not null default &quot;&#x2F;&quot;);</code></pre></li>\n<li><p>插入数据（insert）: 记录的版本号既是当前事务的版本号</p>\n  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">insert into users values(1,&quot;rumple&quot;);</code></pre>\n<p>  假设事务id为1，那么插入后的数据行为</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">name</th>\n<th align=\"center\">create version</th>\n<th align=\"center\">delete version</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">rumple</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>更新</p>\n<ol>\n<li>先标记旧的那一行记录为已删除，并且版本号是事务版本号</li>\n<li>插入一行新的记录<br>  比如：事务id为2更新name字段   <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">update users set name&#x3D;&quot;lily&quot; where id&#x3D;1;</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">name</th>\n<th align=\"center\">create version</th>\n<th align=\"center\">delete version</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">rumple</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">lily</td>\n<td align=\"center\">2</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n<li><p>删除：把事务版本号当做删除版本号</p>\n  <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">delete from users where id&#x3D;1;</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">name</th>\n<th align=\"center\">create version</th>\n<th align=\"center\">delete version</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">lily</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>查询：从上面的操作可以看出来，符合如下两个条件才能被查询出来</p>\n<ol>\n<li>删除版本号未指定或者大于当前事务版本号，用白话讲就是查询事务开启后需要确保读取的行没有被删除（事务id&#x3D;2的查询 依旧可查询到事务id&#x3D;3所删除的数据）</li>\n<li>创建版本号小于等于当前事务版本号，也就是说（事务id&#x3D;2的 只能读取到 create version &lt;&#x3D;2 的已提交数据）</li>\n</ol>\n</li>\n</ol>\n","text":"什么是MVCC？ 英文全称为Multi-Version Concurrency Control,即多版本并发控制。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。 原理 MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%9F\"><span class=\"toc-text\">什么是MVCC？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">InnoDB的MVCC实现策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E7%A4%BA%E4%BE%8B%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\"><span class=\"toc-text\">通过示例来看看是如何工作的</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"关于消息队列的常见问题","uid":"d4819b7b42636665ecebcade56925532","slug":"mq/关于消息队列的常见问题","date":"2020-11-13T02:31:17.000Z","updated":"2022-03-13T04:40:34.550Z","comments":true,"path":"api/articles/mq/关于消息队列的常见问题.json","keywords":"golang rust python docker k8s","cover":null,"text":"1. 如何确保消息正确地发送至RabbitMQ？RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。 发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":2,"path":"api/categories/消息队列.json"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","count":2,"path":"api/tags/rabbitmq.json"},{"name":"mq","slug":"mq","count":1,"path":"api/tags/mq.json"},{"name":"消息队列","slug":"消息队列","count":1,"path":"api/tags/消息队列.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"python调用rust与go生成的库文件","uid":"9675eb8263b3ddc03bf1d31763c2e083","slug":"rust/python-rust-go","date":"2020-11-11T03:09:44.000Z","updated":"2021-12-11T02:10:04.781Z","comments":true,"path":"api/articles/rust/python-rust-go.json","keywords":"golang rust python docker k8s","cover":[],"text":"Python,Rust,Go 我最喜欢的三门语言。 今天来搞一下 分别用rust&amp;&amp;go生成.so文件供python调用，顺便简单测试一下他们之间的性能差距 版本 Python: 3.8.6 Go: 1.15.3 Rust: 1.49.0-nightly (25f...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"rust","slug":"rust","count":1,"path":"api/categories/rust.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"},{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"},{"name":"rust","slug":"rust","count":1,"path":"api/tags/rust.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}