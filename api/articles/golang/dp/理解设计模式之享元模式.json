{"title":"理解设计模式之享元模式","uid":"0e88d00be424e9da6d7f13b5a9de850e","slug":"golang/dp/理解设计模式之享元模式","date":"2020-10-26T06:22:51.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之享元模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>享元模式是指：从对象中剥离出不发生改变且多个实例都需要的重复数据（当然这个数据也可以是对象），独立出一个享元，从而减少对象的创建，节省内存</p>\n<span id=\"more\"></span>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\ntype ImageFactory struct &#123;\n\tmaps map[string]*Image\n&#125;\n\nfunc NewImageFactory() *ImageFactory &#123;\n\treturn &amp;ImageFactory&#123;maps: make(map[string]*Image)&#125;\n&#125;\n\n&#x2F;&#x2F; 获取共享数据\nfunc (f *ImageFactory) Get(filename string) *Image &#123;\n\tvar image &#x3D; f.maps[filename]\n\tif image &#x3D;&#x3D; nil &#123;\n\t\t&#x2F;&#x2F; 当没有这个数据的时候,才进行新建\n\t\timage &#x3D; NewImage(filename)\n\t\tf.maps[filename] &#x3D; image\n\t&#125;\n\treturn image\n&#125;\n\n&#x2F;&#x2F; 共享数据对象\ntype Image struct &#123;\n\tdata string\n&#125;\n\n&#x2F;&#x2F; 新建共享数据对象\nfunc NewImage(filename string) *Image &#123;\n\treturn &amp;Image&#123;\n\t\tdata: fmt.Sprintf(&quot;image data %s&quot;, filename),\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 返回对象数据\nfunc (i *Image) Data() string &#123;\n\treturn i.data\n&#125;\n\ntype ImageViewer struct &#123;\n\t*Image\n&#125;\n\nfunc NewImageViewer(filename string, imageFactory *ImageFactory) *ImageViewer &#123;\n\treturn &amp;ImageViewer&#123;\n\t\tImage: imageFactory.Get(filename),\n\t&#125;\n&#125;\n\nfunc (i *ImageViewer) Display() &#123;\n\tfmt.Printf(&quot;Display: %s\\n&quot;, i.Data())\n&#125;\n\nfunc main() &#123;\n\tnif :&#x3D; NewImageFactory()\n\tiv :&#x3D; NewImageViewer(&quot;beauty&quot;, nif)\n\tiv.Display()\n&#125;</code></pre>","text":"享元模式是指：从对象中剥离出不发生改变且多个实例都需要的重复数据（当然这个数据也可以是对象），独立出一个享元，从而减少对象的创建，节省内存 package main import &quot;fmt&quot; type ImageFactory struct &#123; ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"toc":"","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"理解设计模式之装饰器模式","uid":"f0bac87a6e91ff11c8f0bc84046165ce","slug":"golang/dp/理解设计模式之装饰器模式","date":"2020-10-26T06:38:34.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之装饰器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"熟悉python的朋友对装饰器肯定不陌生，他的定义就是在不改变原有定义的情况下，动态的添加功能。这里的装饰器模式其实也是一个意思 首先来看一个最简单的,在go中函数是一等公民，所以是可以当成参数传递的，那么这就简单了。 func pprint() &#123; fmt.Print...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"理解设计模式之组合模式","uid":"ae24c711008000da26e897d1dea4a2e7","slug":"golang/dp/理解设计模式之组合模式","date":"2020-10-26T05:37:01.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之组合模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"组合模式可以统一对象以及对象集，之后可以使用相同接口去访问这些对象和对象集组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。 这里咱们就直接创建一个树。 package main import ( &quot;log&quot; ) &...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}