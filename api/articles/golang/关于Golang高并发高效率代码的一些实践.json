{"title":"关于Golang高并发高效率代码的一些实践","uid":"771a458cad4b66e91f1476adf7a25646","slug":"golang/关于Golang高并发高效率代码的一些实践","date":"2020-11-18T09:49:19.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/关于Golang高并发高效率代码的一些实践.json","keywords":"golang rust python docker k8s","cover":[],"content":"<h3 id=\"Go的并发\"><a href=\"#Go的并发\" class=\"headerlink\" title=\"Go的并发\"></a>Go的并发</h3><p>  Go语言是原生支持并发的，它和传统基于OS线程和进程的实现不同，Go语言的并发是基于用户态的并发，这种并发方式就变得非常轻量，能够轻松运行几万甚至是几十万的并发逻辑。因此使用Go开发的服务端应用采用的就是“协程模型”，每一个请求由独立的协程处理完成、</p>\n<ul>\n<li><p>并发模型<br>  Go的并发属于CSP并发模型的一种实现，CSP并发模型的核心概念是：“不要通过共享内存来通信，而应该通过通信来共享内存”。这在Go语言中的实现就是Goroutine和Channel。</p>\n<ul>\n<li>goroutine 是 go 的协程对象，用于创建协程并发执行任务的基本单元</li>\n<li>channel 是一个并发安全的FIFO队列，用于协程之间的通信。<span id=\"more\"></span></li>\n</ul>\n</li>\n<li><p>GMP模型：Go的线程调度模型</p>\n<ul>\n<li>G (Goroutine)</li>\n<li>M (Machine): 对应系统内核线程</li>\n<li>P (Processor): 它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列<br><img src=\"/images/golang/gmp.png\" alt=\"gmp\"></li>\n</ul>\n<p>在Go中，线程(M)是运行(G)的实体，调度器处理器(P)的功能是把可运行的(G)分配到工作线程(M)上。<br>调度：</p>\n<ul>\n<li>GlobalQueue: 全局队列，存放等待运行的G</li>\n<li>P’s LocalQuene: P的本地队列 同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>\n<li>P List: 所有的P都在程序启动时创建，并保存在数组中，默认和系统的逻辑cpu个数相同，可通过<code>runtime.GOMAXPROCS(n)</code>设置。</li>\n<li>M: 线程想执行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列拿一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 go语言本身会设置M的最大数量默认为10000，但一般内核很难支持到这么多。可以通过<code>debug.SetMaxThreads(n)</code> 进行设置.</li>\n</ul>\n<p>虽然P和M总是在一起协作执行，但他们的数量却没有什么绝对性的关系，一个M阻塞了，P就会去创建另一个M或者切换另一个M。</p>\n</li>\n</ul>\n<h3 id=\"并发控制\"><a href=\"#并发控制\" class=\"headerlink\" title=\"并发控制\"></a>并发控制</h3><p>  go的并发特性是如此的简单易用，实际过程中，当然会大量用到，尤其涉及到网络I&#x2F;O的过程，比如RPC的调用，数据库，邮件等等。</p>\n<ul>\n<li>假设在一个API接口调用中，关联了3个RPC服务的调用，接口需要等待3个服务的返回结果。为了避免长时间等待，会用到超时的概念，在请求超时后，避免资源泄露，进行相关处理。</li>\n<li>在go中有两个模块与上述功能息息相关，写并发程序必会用到的<ul>\n<li>Context<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n  &quot;context&quot;\n  &quot;fmt&quot;\n  &quot;time&quot;\n)\n\nfunc work(ctx context.Context) &#123;\n\n  for &#123;\n    select &#123;\n    case &lt;-ctx.Done(): &#x2F;&#x2F; context超时取消函数被触发结束任务\n      fmt.Println(&quot;任务被取消&quot;)\n      return\n    default:\n      time.Sleep(time.Second * 1)\n      fmt.Println(&quot;i am working&quot;)\n    &#125;\n  &#125;\n\n&#125;\n\nfunc main() &#123;\n  ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 4*time.Second)\n\n  go work(ctx)\n  for i :&#x3D; 0; i &lt; 10; i++ &#123;\n    time.Sleep(2 * time.Second)\n  &#125;\n&#125;</code></pre></li>\n<li>WaitGroup<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;sync&quot;\n\nfunc work(wg *sync.WaitGroup) &#123;\n  defer wg.Done()\n&#125;\n\nfunc main() &#123;\n  wg :&#x3D; sync.WaitGroup&#123;&#125;\n  for i :&#x3D; 0; i &lt;&#x3D; 10; i++ &#123;\n    wg.Add(1)\n    go work(&amp;wg)\n  &#125;\n  wg.Wait()\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"超时控制\"><a href=\"#超时控制\" class=\"headerlink\" title=\"超时控制\"></a>超时控制</h3><p>  合理的超时控制，对于构建大规模的可靠的微服务架构显得非常重要，不合理的设置将会导致整个调用链上的服务雪崩。<br>  比如 我们有一个被很多上游服务依赖的服务 \bA, 由于一些原因，导致A的响应总是很慢，导致所有的上级服务都会阻塞在A的调用上，导致请求阻塞在A上无法释放，进而影响所有上级服务链。</p>\n<ul>\n<li>在go中server处理 就是每一个请求都会分配一个goroutine去进行handle，如果服务响应慢，阻塞，在高并发情况，下很容易造成段时间内的大量goroutine堆积，每个goroutine因为逻辑的不同占用不同大小的内存，很快服务就会吞噬掉内存。</li>\n<li>协程暴涨和内存使用激增会加剧 Go 调度器和运行时 GC 的负担，进而再次影响服务的处理能力，这种恶性循环会导致整个服务不可用。</li>\n<li>解决办法有蛮多种，不过不同的办法，适应的情况不同<ol>\n<li>协程池，控制整体最大可运行的协程数量，从而进一步限制了内存的使用占用</li>\n<li>限流排队策略，比如令牌桶算法。 </li>\n<li>Money(你懂的)</li>\n<li>在微服务中，有一个叫做熔断机制的东西，其实就是并发超时控制<ul>\n<li>在一次完整的网络连接调用中，总共有三个部分会涉及到耗时，有耗时那就有可能超时，1.建立连接的时候，2.读取数据超时，3.写入数据超时。而go都提供了与之对应的控制函数 <code>    conn.SetReadDeadline()</code>,<code>conn.SetWriteDeadline()</code> </li>\n<li>而当你使用成熟的微服务框架，熔断机制，可能只是其中的一个组件。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>  想要获得最好的程序性能，对程序进行性能分析，是必不可少的 比如：</p>\n<ul>\n<li>CPU使用分析</li>\n<li>协程调用栈</li>\n<li>GC日志</li>\n<li>Trace分析工具<br>  好在这些功能 Go 自身都已经完整的提供了，<ul>\n<li><code>pprof</code></li>\n<li><code>GODEBUG=gctrace=1 go run main.go 2&gt; log_file</code> </li>\n<li><code>go tool trace</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一些写出高性能Go代码的点\"><a href=\"#一些写出高性能Go代码的点\" class=\"headerlink\" title=\"一些写出高性能Go代码的点\"></a>一些写出高性能Go代码的点</h3><ul>\n<li>注重锁的使用，尽量做到锁变量而不要锁过程</li>\n<li>可以使用 CAS，则使用 CAS 操作</li>\n<li>针对热点代码要做针对性优化</li>\n<li>不要忽略 GC 的影响，尤其是高性能低延迟的服务</li>\n<li>合理的对象复用可以取得非常好的优化效果</li>\n<li>尽量避免反射，在高性能服务中杜绝反射的使用</li>\n<li>有些情况下可以尝试调优“GOGC”参数</li>\n<li>新版本稳定的前提下，尽量升级新的 Go 版本，因为旧版本永远不会变得更好</li>\n<li>优化业务逻辑，有时候很多逻辑仔细想想是有很大优化空间的。</li>\n</ul>\n","text":"Go的并发 Go语言是原生支持并发的，它和传统基于OS线程和进程的实现不同，Go语言的并发是基于用户态的并发，这种并发方式就变得非常轻量，能够轻松运行几万甚至是几十万的并发逻辑。因此使用Go开发的服务端应用采用的就是“协程模型”，每一个请求由独立的协程处理完成、 并发模型 Go的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":2,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":4,"path":"api/tags/go.json"},{"name":"高并发","slug":"高并发","count":1,"path":"api/tags/高并发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Go%E7%9A%84%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">Go的并发</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">并发控制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">超时控制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">性能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E5%86%99%E5%87%BA%E9%AB%98%E6%80%A7%E8%83%BDGo%E4%BB%A3%E7%A0%81%E7%9A%84%E7%82%B9\"><span class=\"toc-text\">一些写出高性能Go代码的点</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"k8s之搭建环境(一)","uid":"3ecf53fd0f043e7fd47d014c92e0e74b","slug":"k8s/1.k8s之搭建环境","date":"2020-11-27T05:18:17.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/1.k8s之搭建环境.json","keywords":"golang rust python docker k8s","cover":[],"text":"flag:从今天开始，我将更新K8S系列博文，从环境搭建，到K8S概念的详解，到在k8s上部署完整项目，乃至有可能对K8S的二次开发。未来可期 MAC1. 安装docker-desktop，这个没什么好说的 docker 2. 配置镜像仓库源进行加速 可以选择的源有很多 dock...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"查看日志相关的命令","uid":"517d2648b07f96d72267ed192f3c0c92","slug":"guide/查看日志相关的命令","date":"2020-11-18T07:38:28.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/查看日志相关的命令.json","keywords":"golang rust python docker k8s","cover":null,"text":"作为一名开发，查询过滤日志去debug 应该是基本功中的基本功了。今天详细介绍一下这些命令 1. head head 与 tail 是一对命令，从字面意思也可以看出其作用 head 是用来查看头部的内容，tail 用来查看尾部的内容 参数： - -q 隐藏文件名 - -v 显示文...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"head","slug":"head","count":1,"path":"api/tags/head.json"},{"name":"grep","slug":"grep","count":1,"path":"api/tags/grep.json"},{"name":"tail","slug":"tail","count":1,"path":"api/tags/tail.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}