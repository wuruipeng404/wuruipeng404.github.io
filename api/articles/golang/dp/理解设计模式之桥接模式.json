{"title":"理解设计模式之桥接模式","uid":"4e7dab327a16c4ff4445f675a754b4bd","slug":"golang/dp/理解设计模式之桥接模式","date":"2020-10-26T06:54:02.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之桥接模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>桥接模式分离抽象部分和实现部分。使得两部分可以独立扩展。</p>\n<span id=\"more\"></span>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 抽象消息接口  定义具体的消息类型\ntype AbsMessage interface &#123;\n\tSendMessage(text, to string)\n&#125;\n\n&#x2F;&#x2F; 真正发消息的接口 发送消息的方式\ntype Message interface &#123;\n\tSend(text, to string)\n&#125;\n\n&#x2F;&#x2F; -------------------------------------\ntype EmailMessage struct&#123;&#125;\n\nfunc (*EmailMessage) Send(text, to string) &#123;\n\tfmt.Printf(&quot;send %s to %s email&quot;, text, to)\n&#125;\n\ntype WechatMessage struct&#123;&#125;\n\nfunc (*WechatMessage) Send(text, to string) &#123;\n\tfmt.Printf(&quot;send %s to %s wechat&quot;, text, to)\n&#125;\n\n&#x2F;&#x2F; 公共消息\ntype CommonMessage struct &#123;\n\tmethod Message\n&#125;\n\nfunc NewCommonMessage(method Message) AbsMessage &#123;\n\treturn &amp;CommonMessage&#123;\n\t\tmethod: method,\n\t&#125;\n&#125;\n\nfunc (m *CommonMessage) SendMessage(text, to string) &#123;\n\tm.method.Send(fmt.Sprintf(&quot;[Common] %s&quot;, text), to)\n&#125;\n\n&#x2F;&#x2F; 紧急消息\ntype UrgencyMessage struct &#123;\n\tmethod Message\n&#125;\n\nfunc NewUrgencyMessage(method Message) AbsMessage &#123;\n\treturn &amp;UrgencyMessage&#123;\n\t\tmethod: method,\n\t&#125;\n&#125;\n\nfunc (m *UrgencyMessage) SendMessage(text, to string) &#123;\n\tm.method.Send(fmt.Sprintf(&quot;[Urgency] %s&quot;, text), to)\n&#125;\n\nfunc main() &#123;\n\tNewCommonMessage(&amp;EmailMessage&#123;&#125;).SendMessage(&quot;Hallo world&quot;, &quot;zhangsan&quot;)\n&#125;</code></pre>\n","text":"桥接模式分离抽象部分和实现部分。使得两部分可以独立扩展。 package main import &quot;fmt&quot; &#x2F;&#x2F; 抽象消息接口 定义具体的消息类型 type AbsMessage interface &#123; SendMessage(...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"理解设计模式之中介者模式","uid":"2f29c37507db5ca2a228334b44c7a06a","slug":"golang/dp/理解设计模式之中介者模式","date":"2020-10-26T09:39:55.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之中介者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"中介者模式是用来封装对象与对象之间的交互，使依赖变简单，使复杂交互简单化，封装在中介者中，显而易见的缺点就是，由于逻辑封装在中介者中，所以中介者以后会越来越复杂 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义中介者类 typ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之装饰器模式","uid":"f0bac87a6e91ff11c8f0bc84046165ce","slug":"golang/dp/理解设计模式之装饰器模式","date":"2020-10-26T06:38:34.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之装饰器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"熟悉python的朋友对装饰器肯定不陌生，他的定义就是在不改变原有定义的情况下，动态的添加功能。这里的装饰器模式其实也是一个意思 首先来看一个最简单的,在go中函数是一等公民，所以是可以当成参数传递的，那么这就简单了。 func pprint() &#123; fmt.Print...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}