{"title":"理解设计模式之装饰器模式","uid":"f0bac87a6e91ff11c8f0bc84046165ce","slug":"golang/dp/理解设计模式之装饰器模式","date":"2020-10-26T06:38:34.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之装饰器模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>熟悉python的朋友对装饰器肯定不陌生，他的定义就是在不改变原有定义的情况下，动态的添加功能。<br>这里的装饰器模式其实也是一个意思</p>\n<span id=\"more\"></span>\n<ol>\n<li><p>首先来看一个最简单的,在go中函数是一等公民，所以是可以当成参数传递的，那么这就简单了。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func pprint() &#123;\n\tfmt.Println(&quot;1234&quot;)\n&#125;\n\nfunc pprintDecorator(a func()) &#123;\n\tfmt.Println(&quot;decorator&quot;)\n\ta()\n\tfmt.Println(&quot;after&quot;)\n&#125;\n\nfunc main() &#123;\n\tpprintDecorator(pprint)\n&#125;\n</code></pre>\n</li>\n<li><p>再来看一个标准的</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n)\n\n&#x2F;&#x2F; 定义一个API, API中只有一个方法就是计算获取结果\ntype API interface &#123;\n\tCalc() int\n&#125;\n\ntype Object struct&#123;&#125;\n\nfunc (*Object) Calc() int &#123;\n\treturn 0\n&#125;\n\n&#x2F;&#x2F; 乘 装饰器\ntype MulDecorator struct &#123;\n\tAPI\n\tnum int\n&#125;\n\nfunc WarpMulDecorator(c API, num int) API &#123;\n\treturn &amp;MulDecorator&#123;\n\t\tAPI: c,\n\t\tnum: num,\n\t&#125;\n&#125;\n\nfunc (d *MulDecorator) Calc() int &#123;\n\treturn d.API.Calc() * d.num\n&#125;\n\n&#x2F;&#x2F; 加 装饰器\ntype AddDecorator struct &#123;\n\tAPI\n\tnum int\n&#125;\n\nfunc WarpAddDecorator(c API, num int) API &#123;\n\treturn &amp;AddDecorator&#123;\n\t\tAPI: c,\n\t\tnum: num,\n\t&#125;\n&#125;\n\nfunc (d *AddDecorator) Calc() int &#123;\n\treturn d.API.Calc() + d.num\n&#125;\n\nfunc main() &#123;\n\tobj :&#x3D; &amp;Object&#123;&#125;\n\td :&#x3D; WarpAddDecorator(obj, 100)\n\tlog.Println(d.Calc())\n&#125;</code></pre></li>\n</ol>\n","text":"熟悉python的朋友对装饰器肯定不陌生，他的定义就是在不改变原有定义的情况下，动态的添加功能。这里的装饰器模式其实也是一个意思 首先来看一个最简单的,在go中函数是一等公民，所以是可以当成参数传递的，那么这就简单了。 func pprint() &#123; fmt.Print...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"理解设计模式之桥接模式","uid":"4e7dab327a16c4ff4445f675a754b4bd","slug":"golang/dp/理解设计模式之桥接模式","date":"2020-10-26T06:54:02.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之桥接模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"桥接模式分离抽象部分和实现部分。使得两部分可以独立扩展。 package main import &quot;fmt&quot; &#x2F;&#x2F; 抽象消息接口 定义具体的消息类型 type AbsMessage interface &#123; SendMessage(...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之享元模式","uid":"0e88d00be424e9da6d7f13b5a9de850e","slug":"golang/dp/理解设计模式之享元模式","date":"2020-10-26T06:22:51.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之享元模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"享元模式是指：从对象中剥离出不发生改变且多个实例都需要的重复数据（当然这个数据也可以是对象），独立出一个享元，从而减少对象的创建，节省内存 package main import &quot;fmt&quot; type ImageFactory struct &#123; ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}