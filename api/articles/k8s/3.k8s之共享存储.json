{"title":"k8s之共享存储(GlusterFS)(三)","uid":"60ad9b5a7955245986176acd6be5e193","slug":"k8s/3.k8s之共享存储","date":"2020-12-25T05:26:26.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/3.k8s之共享存储.json","keywords":"golang rust python docker k8s","cover":null,"content":"<h3 id=\"K8S共享存储介绍\"><a href=\"#K8S共享存储介绍\" class=\"headerlink\" title=\"K8S共享存储介绍\"></a>K8S共享存储介绍</h3><ul>\n<li>K8S 对于有状态的容器应用 或者 需要数据持久化的数据应用，不仅需要将容器内的目录挂载到宿主机的目录或者emptyDir临时存储卷，而且需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。</li>\n<li>为了方便使用和管理，K8S实现了三种抽象资源，PersistentVolume（PV）和 PersistentVolumeClaim（PVC）以及 StorageClass,关于三者的概念解释，可以参考上一篇K8S基础概念理解。<span id=\"more\"></span></li>\n<li>抽象的资源对象对应的其实是实际的存储服务，K8S支持非常多的存储服务，而本地最常用的 是NFS，CephFS 以及GlusterFS</li>\n</ul>\n<h3 id=\"GlusterFS简介\"><a href=\"#GlusterFS简介\" class=\"headerlink\" title=\"GlusterFS简介\"></a>GlusterFS简介</h3><p>  GlusterFS 是一个可扩展，分布式文件系统，集成来自多台服务器上的磁盘存储资源到单一全局命名空间，提供共享文件存储。<br>  特性：</p>\n<ul>\n<li>可以扩展到几PB容量</li>\n<li>支持处理数千个客户端</li>\n<li>兼容POSIX接口</li>\n<li>使用通用硬件，普通服务器即可构建</li>\n<li>能够使用支持扩展属性的文件系统，例如ext4，XFS</li>\n<li>支持工业标准的协议，例如NFS，SMB</li>\n<li>提供很多高级功能，例如副本，配额，跨地域复制，快照以及bitrot检测</li>\n<li>支持根据不同工作负载进行调优</li>\n</ul>\n<h4 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h4><ol>\n<li>首先K8S集群要先搭建好</li>\n<li>GlusterFS有两种安装方式，1 直接安装在K8S集群中（需要一些硬性条件），2 传统物理部署。这里由于我本地资源有限所以选择第二种。</li>\n<li>准备三台虚拟机，系统为centos7.x<ul>\n<li>192.168.10.21</li>\n<li>192.168.10.22</li>\n<li>192.168.10.23</li>\n</ul>\n</li>\n<li>安装，分别在每台机器执行如下命令<ol>\n<li>安装源 <code>yum -y install centos-release-gluster</code></li>\n<li>安装glusterfs组件 <code>yum install -y glusterfs glusterfs-server glusterfs-fuse glusterfs-rdma glusterfs-geo-replication glusterfs-devel</code></li>\n<li>启动服务 <code>systemctl enable --now glusterd</code></li>\n</ol>\n</li>\n<li>集群配置<ol>\n<li>修改每一台机器的hosts文件<ul>\n<li>192.168.10.21<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">127.0.0.1     gfs1\n192.168.10.22 gfs2\n192.168.10.23 gfs3</code></pre></li>\n<li>192.168.10.22<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">192.168.10.21 gfs1\n127.0.0.1     gfs2\n192.168.10.23 gfs3</code></pre></li>\n<li>以此类推</li>\n</ul>\n</li>\n<li>添加节点，假设我们在gfs1节点操作 <pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">gluster peer probe gfs2\ngluster peer probe gfs3\ngluster peer status</code></pre></li>\n</ol>\n</li>\n<li>volume<br>&gt; glusterfs volume 有几种模式<br>1. DHT默认模式 <ul>\n<li>也叫分布卷，将文件已hash算法随机分布到 一台服务器节点中存储。</li>\n<li>命令格式：<code>gluster volume create test-volume server1:/exp1 server2:/exp2</code><ol start=\"2\">\n<li>AFR复制模式</li>\n</ol>\n</li>\n<li>创建volume 时带 replica x 数量: 将文件复制到 replica x 个节点中。</li>\n<li>命令格式：<code>gluster volume create test-volume replica 2 transport tcp server1:/exp1 server2:/exp2</code><ol start=\"3\">\n<li>Striped条带模式</li>\n</ol>\n</li>\n<li>创建volume 时带 stripe x 数量： 将文件切割成数据块，分别存储到 stripe x 个节点中 ( 类似raid 0 )。</li>\n<li>命令格式：<code>gluster volume create test-volume stripe 2 transport tcp server1:/exp1 server2:/exp2</code><ol start=\"4\">\n<li>分布式条带模式（组合型）</li>\n</ol>\n</li>\n<li>最少需要4台服务器才能创建。 创建volume 时 stripe 2 server &#x3D; 4 个节点： 是DHT 与 Striped 的组合型。</li>\n<li>命令格式：<code>gluster volume create test-volume stripe 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4</code><ol start=\"5\">\n<li>分布式复制模式（组合型）</li>\n</ol>\n</li>\n<li>最少需要4台服务器才能创建。 创建volume 时 replica 2 server &#x3D; 4 个节点：是DHT 与 AFR 的组合型。</li>\n<li>命令格式：<code>gluster volume create test-volume replica 2 transport tcp server1:/exp1 server2:/exp2　server3:/exp3 server4:/exp4</code> <ol start=\"6\">\n<li>条带复制卷模式（组合型）</li>\n</ol>\n</li>\n<li>最少需要4台服务器才能创建。 创建volume 时 stripe 2 replica 2 server &#x3D; 4 个节点： 是 Striped 与 AFR 的组合型。</li>\n<li>命令格式：<code>gluster volume create test-volume stripe 2 replica 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4</code><ol start=\"7\">\n<li>三种混合模式</li>\n</ol>\n</li>\n<li>至少需要8台 服务器才能创建。 stripe 2 replica 2 , 每4个节点 组成一个 组。</li>\n<li>命令格式：<code>gluster volume create test-volume stripe 2 replica 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4 server5:/exp5 server6:/exp6 server7:/exp7 server8:/exp8</code></li>\n</ul>\n</li>\n<li>创建volume进行测试<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">gluster volume create k8s-volume gfs1:&#x2F;app&#x2F;tv gfs2:&#x2F;app&#x2F;tv gfs3:&#x2F;app&#x2F;tv\n\n# 查看volume状态\ngluster volume info\n\n# 启动volume\ngluster volume start k8s-volume</code></pre></li>\n<li>GlusterFS性能调整选项<br><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"># 开启 指定 volume 的配额\ngluster volume quota k8s-volume enable\n\n# 限制 指定 volume 的配额\ngluster volume quota k8s-volume limit-usage &#x2F; 1TB\n\n# 设置 cache 大小, 默认32MB\ngluster volume set k8s-volume performance.cache-size 4GB\n\n# 设置 io 线程, 太大会导致进程崩溃\ngluster volume set k8s-volume performance.io-thread-count 16\n\n# 设置 网络检测时间, 默认42s\ngluster volume set k8s-volume network.ping-timeout 10\n\n# 设置 写缓冲区的大小, 默认1M\ngluster volume set k8s-volume performance.write-behind-window-size 1024MB</code></pre></li>\n<li>搭建私有镜像仓库，使用volume<br>1. 首先要创建gluster相关服务<br><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">kind: Endpoints\napiVersion: v1\nmetadata:\n  name: glusterfs-cluster\nsubsets:\n  - addresses:\n      - ip: 192.168.10.21\n    ports:\n      - port: 24007\n  - addresses:\n      - ip: 192.168.10.22\n    ports:\n      - port: 24007\n  - addresses:\n      - ip: 192.168.10.23\n    ports:\n      - port: 24007\n\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: glusterfs-cluster\nspec:\n  ports:\n    - port: 34007</code></pre><br>2. 正式使用<br><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: registry-pv\n  labels:\n    name: registry-pv\nspec:\n  capacity:\n    storage: 20Gi\n  accessModes:\n    - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain  # 回收策略  :: 保留,回收,删除\n\n  glusterfs:\n    endpoints: glusterfs-cluster\n    path: k8s_registry_volume\n    readOnly: false\n---\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: registry-pvc\n\nspec:\n  accessModes:\n    - ReadWriteMany # 多节点挂载 这里的节点指的是 Node\n  resources:\n    requests:\n      storage: 20Gi\n  selector:\n    matchLabels:\n      name: registry-pv\n---\nkind: Deployment\napiVersion: apps&#x2F;v1\nmetadata:\n  name: registry-deploy\n  labels:\n    name: registry-deploy\nspec:\n  selector:\n    matchLabels:\n      name: registry\n  template:\n    metadata:\n      labels:\n        name: registry\n    spec:\n      containers:\n        - name: registry\n          image: registry:latest\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 5000\n          volumeMounts:\n            - mountPath: &quot;&#x2F;var&#x2F;lib&#x2F;registry&quot;\n              name: registry-data\n      volumes:\n        - name: registry-data\n          persistentVolumeClaim:\n            claimName: registry-pvc\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: registry\n  labels:\n    name: registry\nspec:\n  type: NodePort\n  ports:\n    - port: 5000\n      nodePort: 30003\n  selector:\n    name: registry  # pod labels</code></pre></li>\n<li>Done!</li>\n</ol>\n","feature":true,"text":"K8S共享存储介绍 K8S 对于有状态的容器应用 或者 需要数据持久化的数据应用，不仅需要将容器内的目录挂载到宿主机的目录或者emptyDir临时存储卷，而且需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。 为了方便使用和管理，K8S实现...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#K8S%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">K8S共享存储介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GlusterFS%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">GlusterFS简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">环境搭建</span></a></li></ol></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"k8s之heketi(四)","uid":"24fa801b1de3778c9ca42278460e2c33","slug":"k8s/4.k8s之Heketi","date":"2021-01-06T06:07:06.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/4.k8s之Heketi.json","keywords":"golang rust python docker k8s","cover":null,"text":"前言 在上一篇中，我们搭建了GlusterFS分布式存储集群。其实搭建好之后就可以创建PV以及PVC进行使用了。但是K8S更进一步的提供一个高级抽象StorageClass, 他主要的作用是对用户设置的PVC申请屏 蔽后端存储的细节，一方面减少了用户对于存储资源细节的关注，另一方...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"heketi","slug":"heketi","count":1,"path":"api/tags/heketi.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},"next_post":{"title":"k8s之基础概念理解(二)","uid":"3ded30373967d6211e6c798b6bf7e484","slug":"k8s/2.k8s之基础概念理解","date":"2020-12-07T06:12:09.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/2.k8s之基础概念理解.json","keywords":"golang rust python docker k8s","cover":[],"text":"本篇主要来解释一下k8s繁多的概念 我觉得吧第一遍不用一定要全部理解，先大致过一下，以后会慢慢熟悉 K8S中的概念按我的理解把他分为这样两类： 架构类：所谓架构类，就是指K8S自身部署，调度，的一些组件和概念 服务类：就是针对我们自己的服务调度，部署，控制，所用到的概念 架构类 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}