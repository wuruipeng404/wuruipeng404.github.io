{"title":"详解MySQL的事务机制","uid":"63b43d983c23e0729b58ec6fc65ef6d7","slug":"mysql/详解MySQL的事务机制","date":"2020-11-10T05:56:05.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/详解MySQL的事务机制.json","keywords":"golang rust python docker k8s","cover":null,"content":"<h4 id=\"1-什么是事务\"><a href=\"#1-什么是事务\" class=\"headerlink\" title=\"1. 什么是事务\"></a>1. 什么是事务</h4><p>  事务就是一组原子性的sql查询，或者说一个独立的工作单元。即事务内的sql语句，要么全部执行成功，要么全部执行失败；</p>\n<h4 id=\"2-ACID\"><a href=\"#2-ACID\" class=\"headerlink\" title=\"2. ACID\"></a>2. ACID</h4><p>  我们都知道事务的四大特性</p>\n<ul>\n<li>原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，基于Redo&#x2F;Undo机制。</li>\n<li>一致性(consistency)：数据库总是从一个一致性状态转移到另一个一致性状态。</li>\n<li>隔离性(isolation)：通常来说，一个事务所做的修改在最终提交前，对其他事务都是不可见的。</li>\n<li>持久性(Durability)：一旦事务提交，则其所做的修改就会永久保存到数据库中；此时即使数据库崩溃，数据也不会丢失。<span id=\"more\"></span></li>\n</ul>\n<h4 id=\"3-事务的隔离级别\"><a href=\"#3-事务的隔离级别\" class=\"headerlink\" title=\"3. 事务的隔离级别\"></a>3. 事务的隔离级别</h4><ul>\n<li><h5 id=\"读未提交（READ-UNCOMMITTED）\"><a href=\"#读未提交（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"读未提交（READ-UNCOMMITTED）\"></a>读未提交（READ-UNCOMMITTED）</h5>事务中的修改，即使没有提交，对其他事务也是可见的。读取未提交的数据称之为<strong>脏读</strong>，这个级别一般挺少使用</li>\n<li><h5 id=\"读提交（READ-COMMITTED）\"><a href=\"#读提交（READ-COMMITTED）\" class=\"headerlink\" title=\"读提交（READ-COMMITTED）\"></a>读提交（READ-COMMITTED）</h5>这个级别是大多数数据库系统的默认隔离级别（但MySQL不是）。一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫作不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。</li>\n<li><h5 id=\"可重复度（REPEATABLE—READ）\"><a href=\"#可重复度（REPEATABLE—READ）\" class=\"headerlink\" title=\"可重复度（REPEATABLE—READ）\"></a>可重复度（REPEATABLE—READ）</h5>MySQL的默认级别，在一个事务内的多次读取结果是一样的，在此级别下可以避免<strong>脏读</strong>，<strong>不可重复读</strong>等查询问题</li>\n<li><h5 id=\"串行化（SERIALIZABLE）\"><a href=\"#串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"串行化（SERIALIZABLE）\"></a>串行化（SERIALIZABLE）</h5>最高的隔离级别，强制事务读写串行执行，除了不会造成数据不一致的问题，没有其他优点</li>\n</ul>\n<h4 id=\"4-常见问题\"><a href=\"#4-常见问题\" class=\"headerlink\" title=\"4. 常见问题\"></a>4. 常见问题</h4><ul>\n<li><h5 id=\"脏读（Dirty-Reads）\"><a href=\"#脏读（Dirty-Reads）\" class=\"headerlink\" title=\"脏读（Dirty Reads）:\"></a>脏读（Dirty Reads）:</h5>一个事务正在访问并修改数据库中的数据但是没有提交，但是另外一个事务可能读取到这些已作出修改但未提交的数据。这样可能导致的结果就是所有的操作都有可能回滚，比如第一个事务对数据做出的修改可能违背了数据表的某些约束，破坏了完整性，但是恰巧第二个事务却读取到了这些不正确的数据造成它自身操作也发生失败回滚。 </li>\n<li><h5 id=\"不可重复读取（Non-Repeatable-Reads）：\"><a href=\"#不可重复读取（Non-Repeatable-Reads）：\" class=\"headerlink\" title=\"不可重复读取（Non-Repeatable Reads）：\"></a>不可重复读取（Non-Repeatable Reads）：</h5>A 事务两次读取同一数据，B事务也读取这同一数据，但是 A 事务在第二次读取前B事务已经更新了这一数据。所以对于A事务来说，它第一次和第二次读取到的这一数据可能就不一致了。 </li>\n<li><h5 id=\"幻读（Phantom-Reads）\"><a href=\"#幻读（Phantom-Reads）\" class=\"headerlink\" title=\"幻读（Phantom Reads）:\"></a>幻读（Phantom Reads）:</h5>与不可重复读有点类似，都是两次读取，不同的是 A 事务第一次操作的比如说是全表的数据，此时 B 事务并不是只修改某一具体数据而是插入了一条新数据，而后 A 事务第二次读取这全表的时候就发现比上一次多了一条数据，发生幻觉了。 </li>\n<li><h5 id=\"更新丢失（Lost-Update）\"><a href=\"#更新丢失（Lost-Update）\" class=\"headerlink\" title=\"更新丢失（Lost Update）:\"></a>更新丢失（Lost Update）:</h5>更新丢失是指并发下两次更新同时进行，后一次更新覆盖了前一次更新的情况，更新丢失是数据没有保证一致性导致的。</li>\n</ul>\n<h4 id=\"5-问题剖析\"><a href=\"#5-问题剖析\" class=\"headerlink\" title=\"5. 问题剖析\"></a>5. 问题剖析</h4><ul>\n<li>脏读和不可重复读在 可重复读的隔离机制下都可以直接避免</li>\n<li><h5 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h5><ul>\n<li>要说明的一点，幻读指的是新插入的行，原本存在的行 更新 结果 不算。</li>\n<li>影响：<ul>\n<li>会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。</li>\n<li>产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。</li>\n</ul>\n</li>\n<li>原因：<ul>\n<li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</li>\n</ul>\n</li>\n<li>解决办法：<ul>\n<li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁。</li>\n<li>间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作。</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>由于 间隙锁 之间 是不互斥的，所以有可能会产生死锁问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h5 id=\"更新丢失\"><a href=\"#更新丢失\" class=\"headerlink\" title=\"更新丢失\"></a>更新丢失</h5><ul>\n<li>解决办法：<ul>\n<li>悲观锁：获取行的时候使用 <code>select xxxx for update</code> 主动加锁</li>\n<li>乐观锁：使用类似MVVC一样的处理办法加上版本控制 从逻辑上去加锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h5 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h5><ul>\n<li>产生原因：<ul>\n<li>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</li>\n</ul>\n</li>\n<li>解决办法：<ul>\n<li>相互等待，直到时间超时（设置死锁超时时间innodb_lock_wait_timeout）</li>\n<li>发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect&#x3D;on）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","text":"1. 什么是事务 事务就是一组原子性的sql查询，或者说一个独立的工作单元。即事务内的sql语句，要么全部执行成功，要么全部执行失败； 2. ACID 我们都知道事务的四大特性 原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"事务机制","slug":"事务机制","count":1,"path":"api/tags/事务机制.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">1. 什么是事务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-ACID\"><span class=\"toc-text\">2. ACID</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">3. 事务的隔离级别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%88READ-UNCOMMITTED%EF%BC%89\"><span class=\"toc-text\">读未提交（READ-UNCOMMITTED）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E6%8F%90%E4%BA%A4%EF%BC%88READ-COMMITTED%EF%BC%89\"><span class=\"toc-text\">读提交（READ-COMMITTED）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%BA%A6%EF%BC%88REPEATABLE%E2%80%94READ%EF%BC%89\"><span class=\"toc-text\">可重复度（REPEATABLE—READ）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%88SERIALIZABLE%EF%BC%89\"><span class=\"toc-text\">串行化（SERIALIZABLE）</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4. 常见问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%84%8F%E8%AF%BB%EF%BC%88Dirty-Reads%EF%BC%89\"><span class=\"toc-text\">脏读（Dirty Reads）:</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%96%EF%BC%88Non-Repeatable-Reads%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">不可重复读取（Non-Repeatable Reads）：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%BB%E8%AF%BB%EF%BC%88Phantom-Reads%EF%BC%89\"><span class=\"toc-text\">幻读（Phantom Reads）:</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1%EF%BC%88Lost-Update%EF%BC%89\"><span class=\"toc-text\">更新丢失（Lost Update）:</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90\"><span class=\"toc-text\">5. 问题剖析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%BB%E8%AF%BB\"><span class=\"toc-text\">幻读</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1\"><span class=\"toc-text\">更新丢失</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a></li></ol></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"github-ssh协议配置代理","uid":"357905e1891b1f51272b4c207482f185","slug":"guide/github-ssh协议配置代理","date":"2020-11-10T07:10:01.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/github-ssh协议配置代理.json","keywords":"golang rust python docker k8s","cover":null,"text":"最近git连github经常抽风 使用 git config --global http.proxy的方式也没用的状态下，就想搞一下ssh协议走代理开搞 配置 .ssh/config Host github.com ProxyCommand ~&#x2F;.ssh&#x2F;ss...","link":"","photos":[],"count_time":{"symbolsCount":493,"symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":6,"path":"api/categories/操作指南.json"}],"tags":[{"name":"git","slug":"git","count":3,"path":"api/tags/git.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"数据结构之链表","uid":"44f9b4429be4a923b3d82ea9a6628937","slug":"ds/数据结构之链表","date":"2020-10-30T05:14:02.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/ds/数据结构之链表.json","keywords":"golang rust python docker k8s","cover":[],"text":"1. 什么是链表 链表是由一组不必相连（可以连续也可以不连续）的内存结构节点，按特定的顺序链接在一起的抽象数据类型 2. 链表的分类 链表常用的有三类，单链表 双向链表 循环链表, 循环链表又分为单项与双向 3. 用Python来实现单向循环链表,其他的大同小异 一般会抽象如下方...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}