{"title":"理解设计模式之建造者模式","uid":"c3aea0285a3783cfb28818d4df287ed0","slug":"golang/dp/理解设计模式之建造者模式","date":"2020-10-23T11:05:37.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之建造者模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>建造者模式主要作用是解耦了创建的过程,将一个复杂对象的创建过程分步完成.<br>下面来讲两种风格的建造者模式</p>\n<span id=\"more\"></span>\n<ol>\n<li>go<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\n&#x2F;&#x2F; 1.传统类型: 由指挥者指挥建造者创建具体的对象\n&#x2F;&#x2F; 创建奥特曼\n&#x2F;&#x2F; 定义建造者接口\ntype Builder interface &#123;\n\tBuildHead()\n\tBuildHand()\n\tBuildLeg()\n\tBuildBody()\n\tShow()\n&#125;\n\n&#x2F;&#x2F; 定义指挥者\ntype Director struct &#123;\n\tbuilder Builder\n&#125;\n\nfunc NewDirector(b Builder) *Director &#123;\n\treturn &amp;Director&#123;builder: b&#125;\n&#125;\n\nfunc (d *Director) Generate() &#123;\n\td.builder.BuildBody()\n\td.builder.BuildHand()\n\td.builder.BuildHead()\n\td.builder.BuildLeg()\n\td.builder.Show()\n&#125;\n\n&#x2F;&#x2F; 定义奥特曼 以及 奥特曼建造者\ntype UltraMan struct &#123;\n\tHead string\n\tHand string\n\tBody string\n\tLeg  string\n&#125;\n\ntype UltraManBuilder struct &#123;\n\tutMan *UltraMan\n&#125;\n\nfunc (b *UltraManBuilder) BuildBody() &#123;\n\tb.utMan.Body &#x3D; &quot;body&quot;\n&#125;\nfunc (b *UltraManBuilder) BuildHand() &#123;\n\tb.utMan.Hand &#x3D; &quot;hand&quot;\n&#125;\nfunc (b *UltraManBuilder) BuildHead() &#123;\n\tb.utMan.Head &#x3D; &quot;head&quot;\n&#125;\nfunc (b *UltraManBuilder) BuildLeg() &#123;\n\tb.utMan.Leg &#x3D; &quot;leg&quot;\n&#125;\n\nfunc (b *UltraManBuilder) Show() &#123;\n\tfmt.Printf(&quot;%+v&quot;, b.utMan)\n&#125;\n\n&#x2F;&#x2F; 2. Golang风格的建造者模式\n&#x2F;&#x2F; 创建一个坦克\ntype Tank struct &#123;\n\tTankLooks string &#x2F;&#x2F; 坦克最终的样子\n\tWheel     bool   &#x2F;&#x2F; 是否有轮子\n\tCannon    bool   &#x2F;&#x2F; 是否有大炮\n\tDriver    bool   &#x2F;&#x2F; 是否有驾驶员\n&#125;\n\nfunc NewTank() *Tank &#123;\n\treturn &amp;Tank&#123;&#125;\n&#125;\n\nfunc (t *Tank) withWheel() *Tank &#123;\n\tt.Wheel &#x3D; true\n\treturn t\n&#125;\n\nfunc (t *Tank) withCannon() *Tank &#123;\n\tt.Cannon &#x3D; true\n\treturn t\n&#125;\nfunc (t *Tank) withDriver() *Tank &#123;\n\tt.Driver &#x3D; true\n\treturn t\n&#125;\n\nfunc (t *Tank) Show() &#123;\n\tif t.Wheel &#123;\n\t\tt.TankLooks +&#x3D; &quot;有轮子,&quot;\n\t&#125; else &#123;\n\t\tt.TankLooks +&#x3D; &quot;没有轮子,&quot;\n\t&#125;\n\n\tif t.Cannon &#123;\n\t\tt.TankLooks +&#x3D; &quot;有大炮,&quot;\n\t&#125; else &#123;\n\t\tt.TankLooks +&#x3D; &quot;没有大炮,&quot;\n\t&#125;\n\n\tif t.Driver &#123;\n\t\tt.TankLooks +&#x3D; &quot;有驾驶员&quot;\n\t&#125; else &#123;\n\t\tt.TankLooks +&#x3D; &quot;无人驾驶&quot;\n\t&#125;\n\n\tfmt.Println(t.TankLooks) &#x2F;&#x2F; or return tank\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; director :&#x3D; NewDirector(&amp;UltraManBuilder&#123;&amp;UltraMan&#123;&#125;&#125;)\n\t&#x2F;&#x2F; director.Generate()\n\ttank :&#x3D; NewTank().withCannon().withDriver()\n\ttank.Show()\n&#125;</code></pre></li>\n</ol>\n<p>2.python</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import abc\n\n\nclass Builder(metaclass&#x3D;abc.ABCMeta):\n\n    @abc.abstractmethod\n    def create_head(self):\n        pass\n\n    @abc.abstractmethod\n    def create_arm(self):\n        pass\n\n    @abc.abstractmethod\n    def create_leg(self):\n        pass\n\n    @abc.abstractmethod\n    def create_dick(self):\n        pass\n\n    @abc.abstractmethod\n    def create_bottom(self):\n        pass\n\n\nclass Dragon(Builder):\n\n    def create_arm(self):\n        print(&quot;建造恐龙手臂&quot;)\n\n    def create_bottom(self):\n        print(&quot;建造恐龙屁股&quot;)\n\n    def create_dick(self):\n        print(&quot;建造恐龙吊&quot;)\n\n    def create_head(self):\n        print(&quot;建造霸王龙头部&quot;)\n\n    def create_leg(self):\n        print(&quot;建造恐龙腿&quot;)\n\n\nclass AUTOMan(Builder):\n\n    def create_leg(self):\n        print(&quot;建造奥特曼腿&quot;)\n\n    def create_head(self):\n        print(&quot;建造奥特曼头&quot;)\n\n    def create_dick(self):\n        print(&quot;建造奥特曼吊&quot;)\n\n    def create_arm(self):\n        print(&quot;建造奥特曼手臂&quot;)\n\n    def create_bottom(self):\n        print(&quot;建造奥特曼屁股&quot;)\n\n\nclass Director(object):\n\n    def __init__(self, someone: Builder):\n        self.someone &#x3D; someone\n\n    def create(self):\n        self.someone.create_leg()\n        self.someone.create_head()\n        self.someone.create_arm()\n        self.someone.create_dick()\n        self.someone.create_bottom()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    dragon &#x3D; Dragon()\n\n    rumple &#x3D; Director(dragon)\n    rumple.create()</code></pre>","text":"建造者模式主要作用是解耦了创建的过程,将一个复杂对象的创建过程分步完成.下面来讲两种风格的建造者模式 gopackage main import &quot;fmt&quot; &#x2F;&#x2F; 1.传统类型: 由指挥者指挥建造者创建具体的对象 &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"理解设计模式之单例模式","uid":"1602c992a6a28c4ed33dd66720a6bf2e","slug":"golang/dp/理解设计模式之单例模式","date":"2020-10-23T12:05:12.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之单例模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"go语言中的单例模式简单到没啥可说的。 正常创建一个全局变量就是，单例为了线程安全你可以加锁，这里直接使用sync.once,原理一样。 go package main import &quot;sync&quot; type Singleton struct&#123;&#12...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之抽象工厂","uid":"c1243241d6dbe40f7f47b73a2a79fbcc","slug":"golang/dp/理解设计模式之抽象工厂","date":"2020-10-23T10:54:34.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之抽象工厂.json","keywords":"golang rust python docker k8s","cover":null,"text":"抽象工厂 是在工厂方法的基础之上进化而来，其中最大的不同点是：工厂方法模式中的工厂 只创建一种对象，而抽象工厂中的工厂 则是创建多种对象，而往往这些对象是有关联的，一个家族的一系列对象，比如 订单和订单详情 go &#x2F;&#x2F; 订单信息接口 type Order in...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}