{"total":57,"pageSize":12,"pageCount":5,"data":[{"title":"github-ssh协议配置代理","uid":"357905e1891b1f51272b4c207482f185","slug":"guide/github-ssh协议配置代理","date":"2020-11-10T07:10:01.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/github-ssh协议配置代理.json","cover":null,"text":"最近git连github经常抽风 使用 git config --global http.proxy的方式也没用的状态下，就想搞一下ssh协议走代理开搞 配置 .ssh/config Host github.com ProxyCommand ~&#x2F;.ssh&#x2F;ss...","link":"","photos":[],"count_time":{"symbolsCount":493,"symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"git","slug":"git","count":2,"path":"api/tags/git.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"详解MySQL的事务机制","uid":"63b43d983c23e0729b58ec6fc65ef6d7","slug":"mysql/详解MySQL的事务机制","date":"2020-11-10T05:56:05.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/详解MySQL的事务机制.json","cover":null,"text":"1. 什么是事务 事务就是一组原子性的sql查询，或者说一个独立的工作单元。即事务内的sql语句，要么全部执行成功，要么全部执行失败； 2. ACID 我们都知道事务的四大特性 原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"事务机制","slug":"事务机制","count":1,"path":"api/tags/事务机制.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"数据结构之链表","uid":"44f9b4429be4a923b3d82ea9a6628937","slug":"ds/数据结构之链表","date":"2020-10-30T05:14:02.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/ds/数据结构之链表.json","cover":[],"text":"1. 什么是链表 链表是由一组不必相连（可以连续也可以不连续）的内存结构节点，按特定的顺序链接在一起的抽象数据类型 2. 链表的分类 链表常用的有三类，单链表 双向链表 循环链表, 循环链表又分为单项与双向 3. 用Python来实现单向循环链表,其他的大同小异 一般会抽象如下方...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"数据结构之线性与非线性","uid":"80648934d5c19eeef307e3bc1f9a947e","slug":"ds/数据结构之线性与非线性","date":"2020-10-30T02:35:58.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/ds/数据结构之线性与非线性.json","cover":[],"text":"数据结构是计算机存储组织数据的方式，常见的数据结构分类如下图： 线性结构 什么是线性结构？ 数据结构中线性结构指的是数据元素之间存在着 一对一 的线性关系的数据结构。线性结构是一个有序数据元素的集合。 线性结构的特点- 线性结构有唯一的首元素（第一个元素）- 线性结构有唯一的尾元...","link":"","photos":[],"count_time":{"symbolsCount":597,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"MySQL8的新特性","uid":"c9eed3f9b00e09f8e1c1149f26ce6969","slug":"mysql/MySQL8的新特性","date":"2020-10-29T07:36:48.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL8的新特性.json","cover":[],"text":"MySQL的版本一下子跳跃这么大，用手指想就有很多新的东西了。下面我们就来详细了解一下。 1. 秒级加列 分别在5.7与8.0中有一张 test 表，数据为3000w行 # mysql8.0.22 mysql&gt; alter table test add str varcha...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"讲明白倒排索引","uid":"e31f27ca5c997bccd8e8b4c8d00251b5","slug":"es/讲明白倒排索引","date":"2020-10-28T09:24:17.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/es/讲明白倒排索引.json","cover":[],"text":"要搞明白倒排索引我们就要先搞明白什么是正排索引 对于搜索引擎来讲，正排索引是文档id到文档内容以及单词的关联关系，也就是说通过id获取到文档的内容，如果拿关系型数据库来解释就是下面这条SQL select * from human where id &#x3D; 3; 倒排索引 ...","link":"","photos":[],"count_time":{"symbolsCount":663,"symbolsTime":"1 mins."},"categories":[{"name":"es","slug":"es","count":2,"path":"api/categories/es.json"}],"tags":[{"name":"倒排索引","slug":"倒排索引","count":1,"path":"api/tags/倒排索引.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"关于RabbitMQ消息队列的可靠性传输","uid":"bd281a987a5c824ac404d854e69b882e","slug":"mq/关于RabbitMQ消息队列的可靠性传输","date":"2020-10-28T05:21:20.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mq/关于RabbitMQ消息队列的可靠性传输.json","cover":null,"text":"在使用消息队列的过程中如何保证消息的可靠性呢？这个问题其实包含了几方面的小问题。 数据丢失问题 数据幂等性的问题 重复消费的问题 我们知道在使用消息队列的时候是必然有三个角色的，生产者，消费者，以及MQ本身。那么数据丢失无非就以下几种情况 生产者传输给MQ 这个过程丢失数据，导致...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":1,"path":"api/categories/消息队列.json"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","count":1,"path":"api/tags/rabbitmq.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之访问者模式","uid":"6861080263609c8f32ead8d0fe52b3fb","slug":"golang/dp/理解设计模式之访问者模式","date":"2020-10-27T08:17:55.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之访问者模式.json","cover":null,"text":"访问者模式主要是为了解决 稳定数据结构与变化的数据操作 耦合的问题。可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。 package main import &quot;fmt&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之责任链模式","uid":"4d590d0702a24ddaf8b311434285f6b8","slug":"golang/dp/理解设计模式之责任链模式","date":"2020-10-27T07:56:07.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之责任链模式.json","cover":null,"text":"责任链模式：分离不同职责 动态的组合相关责任链责任链上的处理者负责处理请求。客户端只需要发送即可这里举一个 通俗易懂的例子，叫家人帮我买手机！ package main import &quot;fmt&quot; &#x2F;&#x2F; 定义一个购买手机的需求 type Re...","link":"","photos":[],"count_time":{"symbolsCount":872,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之解释器模式","uid":"f06ad8235feac5c0bb5f9c61b04ab4af","slug":"golang/dp/理解设计模式之解释器模式","date":"2020-10-27T07:28:27.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之解释器模式.json","cover":null,"text":"解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。 package main import &qu...","link":"","photos":[],"count_time":{"symbolsCount":821,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之备忘录模式","uid":"31a528ce1cc912e617e7cd21630fdad9","slug":"golang/dp/理解设计模式之备忘录模式","date":"2020-10-27T07:08:52.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之备忘录模式.json","cover":null,"text":"备忘录，字面意思，一般会用来保存程序快照。或者 将内部程序的状态暴露给 外部，而不展示具体细节 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义备忘录接口 type Memo interface &#123; Save() M...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之状态模式","uid":"57343b3b347c194726d5fcd7c1e57903","slug":"golang/dp/理解设计模式之状态模式","date":"2020-10-27T06:58:29.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之状态模式.json","cover":null,"text":"状态模式没啥好说的，就是用来分离行为与状态的。直接看例子 package main import &quot;fmt&quot; type Week interface &#123; Today() Next(*DayContext) &#125; type DayContext...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}]}