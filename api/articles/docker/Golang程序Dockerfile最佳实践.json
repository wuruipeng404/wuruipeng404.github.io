{"title":"Golang程序Dockerfile最佳实践","uid":"e68c644f0327c9651998fad434541edf","slug":"docker/Golang程序Dockerfile最佳实践","date":"2020-10-16T08:51:49.000Z","updated":"2022-03-12T04:51:59.775Z","comments":true,"path":"api/articles/docker/Golang程序Dockerfile最佳实践.json","keywords":"golang rust python docker k8s","cover":[],"content":"<p>众所周知，通过Dockerfile去构建镜像是分层执行的，\b如何使我们的镜像最小化，以及不会泄露源代码等，我总结一个比较通用的Dockerfile.</p>\n<span id=\"more\"></span>\n\n<pre class=\"line-numbers language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">FROM golang:latest as builder\n\nWORKDIR  &#x2F;home&#x2F;works&#x2F;program\n\nADD .. .\nARG GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn\nRUN go build -o bin&#x2F;main src&#x2F;main.go\n\nFROM alpine:latest\n\nRUN echo &quot;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;latest-stable&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\\n    &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;apk&#x2F;* \\\n    &amp;&amp; rm -rf &#x2F;tmp&#x2F;* \\\n    &amp;&amp; apk update \\\n    &amp;&amp; apk add --no-cache -U tzdata ca-certificates libc6-compat libgcc libstdc++ \\\n    &amp;&amp; cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime \\\n    &amp;&amp; echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone \\\n    &amp;&amp; apk del tzdata\n\nWORKDIR  &#x2F;home&#x2F;works&#x2F;program\n\nEXPOSE 8000\n\nCOPY --from&#x3D;builder &#x2F;home&#x2F;works&#x2F;program&#x2F;bin&#x2F; .&#x2F;\nCOPY .&#x2F;configs&#x2F;settings.yml .&#x2F;configs&#x2F;settings.yml\n\nCMD .&#x2F;main</code></pre>\n\n<p>说明：</p>\n<ul>\n<li>我们使用镜像golang:latest去编译，而实际运行的镜像则是从上层编译环境中copy过来而生产，这样做的好处是，运行的镜像只有编译后的二进制文件，没有各种依赖库，而且源代码也不在其中。是最小的状态。</li>\n<li>Dockerfile中<code>RUN</code>一次执行了多条命令，如果我们把多条命令分为多条RUN，那镜像的层数就会大大增加。体积也会变大</li>\n<li>注意 <code>.dockerignore</code> 文件的使用，将不必要的文件及目录写入其中，这样会大大减少docker build过程中 daemon context的大小。</li>\n<li>我喜欢用 <code>CMD</code> 而不是 <code>ENTRYPOINT</code> 的原因是因为，一旦你的程序有问题跑步起来，你想 <code>docker exec</code> 进入容器内部debug时，使用 <code>ENTRYPOINT</code> 是进不去的，而实际使用效果来说两者差别不大。</li>\n<li>不过上述Dockerfile还有个问题就是 每次build都需要重新下载依赖库，公司开了外网，网速快，当然没什么压力，如果没有，还有随着项目越来越大依赖越来越多，构建都是很慢的。  解决办法有两个，1.自己维护一个基础编译镜像，安装好所有的依赖包，这个就是增添了维护的烦恼。2.直接在自己的电脑上交叉编译，将二进制文件直接添加进容器，直接去除实时编译，这种会快不少。</li>\n</ul>\n<p>更新:<br>  上面的方式一般本地开发没啥问题,但是集成到cicd流程当中去的时候可能就会有些问题了.<br>  接下来我们要进行优化. 解决以下几个点</p>\n<ol>\n<li>解决每次构建都要重新下载pkg的问题</li>\n<li>解决私有仓库的拉取问题</li>\n<li>去除不必要的CGO依赖</li>\n</ol>\n<p>先上Dockerfile</p>\n<pre class=\"line-numbers language-Dockerfile\" data-language=\"Dockerfile\"><code class=\"language-Dockerfile\">#syntax&#x3D;docker&#x2F;dockerfile:latest\nFROM golang:latest as builder\n\nWORKDIR &#x2F;app\n\nADD . .\n\nENV GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct \\\n    GOINSECURE&#x3D;gitlab.yourdomain.com&#x2F;yourgroup \\\n    GONOPROXY&#x3D;gitlab.yourdomain.com&#x2F;yourgroup \\\n    GONOSUMDB&#x3D;gitlab.yourdomain.com&#x2F;yourgroup \\\n    GOPRIVATE&#x3D;gitlab.yourdomain.com&#x2F;yourgroup \\\n\nRUN echo &quot;machine gitlab.yourdomain.com \\n login gitlab-ci-token \\n password deploytoken&quot; &gt; ~&#x2F;.netrc\n\nRUN --mount&#x3D;type&#x3D;cache,id&#x3D;go_mod,target&#x3D;&#x2F;go&#x2F;pkg&#x2F;mod \\\n    --mount&#x3D;type&#x3D;cache,id&#x3D;odp_go_cache,target&#x3D;&#x2F;root&#x2F;.cache&#x2F;go-build \\\n    CGO_ENABLED&#x3D;0 go build -o bin&#x2F;trans .&#x2F;main.go\n\n\nFROM alpine:latest\n\nRUN echo &quot;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;latest-stable&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\\n    &amp;&amp; apk update \\\n    &amp;&amp; apk add tzdata \\\n    &amp;&amp; cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime \\\n    &amp;&amp; echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone \\\n    &amp;&amp; apk del tzdata\n\nWORKDIR &#x2F;home&#x2F;works&#x2F;program\n\nARG config&#x3D;config\n\nEXPOSE 8000\n\nENV GIN_MODE&#x3D;release\nCOPY --from&#x3D;builder &#x2F;app&#x2F;bin .&#x2F;\nCOPY .&#x2F;config&#x2F;$&#123;config&#125;.yaml .&#x2F;config&#x2F;config.yaml\nCOPY .&#x2F;static .&#x2F;static\nCMD .&#x2F;trans</code></pre>\n\n<ul>\n<li><p>首先dockerfile语法也是有版本的<img src=\"https://docs.docker.com/develop/develop-images/build_enhancements/\" alt=\"BuildKit\"> 也就是BuildKit的版本, 我们开头的 <code>#syntax=docker/dockerfile:latest</code> 就是指定最新的语法, 不然有些功能是无法使用的.</p>\n</li>\n<li><p>环境变量: 如果你有私有包,比如我这里,是将私有包管理在内网的gitlab,这里就需要配置所需的几个go环境变量</p>\n</li>\n<li><p><code>~/.netrc</code> 文件的修改. 是为了配置gitlab的认证. 如果你搜索过相关问题的话,其他人会告诉你需要在 git中配置 <code>git config --global url.&quot;git@mygitlab.com:&quot;.insteadOf &quot;http://mygitlab.com/&quot;</code> 这种方式本地开发可以, 但是在ci流程中就不太好</p>\n</li>\n<li><p><img src=\"/images/golang/cache.png\" alt=\"cache\"> 这里的主要作用,是为了缓存package,不用每次构建都重新下载package,他会将package给缓存到宿主机上, 之后每次都会先从缓存中读取. 这里构建的时候也将CGO给关闭了, cgo是默认开启的,如果你的代码里没有用到cgo, 而又开启了,那在之后的alpine基础镜像内就需要安装gcc相关依赖 <code>apk add libc6-compat libgcc libstdc++</code>,否则你的程序是无法运行的.</p>\n</li>\n</ul>\n","text":"众所周知，通过Dockerfile去构建镜像是分层执行的，\b如何使我们的镜像最小化，以及不会泄露源代码等，我总结一个比较通用的Dockerfile. FROM golang:latest as builder WORKDIR &#x2F;home&#x2F;works&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"docker","slug":"docker","count":2,"path":"api/categories/docker.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"},{"name":"docker","slug":"docker","count":2,"path":"api/tags/docker.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"用简单的话讲明白MySQL索引","uid":"5a2cdee73626da8985a23805f627ad4f","slug":"mysql/用简单的话讲明白索引","date":"2020-10-20T01:57:21.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/用简单的话讲明白索引.json","keywords":"golang rust python docker k8s","cover":[],"text":"索引的作用顾名思义，索引其实就是字面意思，和我们以前查字典的索引是一样的意思，能够帮助我们快速的查找到相关数据，这就是索引，哈希表的键，人的名字，工号，身份证号，这些都是索引 BTree(B-Tree) B树和B-树其实是一个意思。它长这个样子 它是一颗多路平衡查找树，我们描述一...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"数据库索引","slug":"数据库索引","count":1,"path":"api/tags/数据库索引.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"Golang程序实现自动更新","uid":"26beaec8904420e53dae414f48ef2055","slug":"golang/Golang程序实现自动更新","date":"2020-10-16T08:03:06.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/Golang程序实现自动更新.json","keywords":"golang rust python docker k8s","cover":null,"text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;我们都知道一个正常的golang程序部署流程大致都要经过编译，测试，发布(人工或者自动化) ，在大公司基础设施完善，当然也未必。我现在就身处于一个上市公司，但是基础建设极其惨不忍睹的公司。扯远了。进入...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"go","slug":"go","count":4,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}