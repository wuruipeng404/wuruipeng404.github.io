{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}},"post_list":[{"title":"http,https,http2,RPC,gRPC,Socket,WebSocket都是些啥","uid":"d71352f907ccd4a5fa2d2fd4965d3b21","slug":"basic/proto","date":"2022-03-12T06:07:20.000Z","updated":"2022-03-12T09:19:18.274Z","comments":true,"path":"api/articles/basic/proto.json","keywords":"golang rust python docker k8s","cover":[],"text":"首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层 http http,https,http2 (统称http) 是应用层协议，主要解决如何包装数据（文本信息），是建立在TCP协议之上的应用。那么这个s,和2分别指的什么呢我们来先...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"网络基础","slug":"网络基础","count":1,"path":"api/categories/网络基础.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},{"title":"封装易用的 Golang Odm","uid":"235660ba99baa3b7d4208214f0acb547","slug":"golang/odm","date":"2022-03-12T04:12:37.000Z","updated":"2022-03-12T05:59:32.181Z","comments":true,"path":"api/articles/golang/odm.json","keywords":"golang rust python docker k8s","cover":null,"text":"在golang中目前需要对mongodb进行操作会接触到如下两个库 mongo-go-driver mongodb官方出的驱动mgo mgo 很久没有维护了. 所以现在大家基本上都在使用官方的driver,但是官方的driver用下来,有一些痛点.所以我决定封装一下.使其用起来像...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"},{"name":"mongo","slug":"go/mongo","count":1,"path":"api/categories/go/mongo.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"mongodb","slug":"mongodb","count":1,"path":"api/tags/mongodb.json"},{"name":"odm","slug":"odm","count":1,"path":"api/tags/odm.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},{"title":"k8s之heketi(四)","uid":"24fa801b1de3778c9ca42278460e2c33","slug":"k8s/4.k8s之Heketi","date":"2021-01-06T06:07:06.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/4.k8s之Heketi.json","keywords":"golang rust python docker k8s","cover":null,"text":"前言 在上一篇中，我们搭建了GlusterFS分布式存储集群。其实搭建好之后就可以创建PV以及PVC进行使用了。但是K8S更进一步的提供一个高级抽象StorageClass, 他主要的作用是对用户设置的PVC申请屏 蔽后端存储的细节，一方面减少了用户对于存储资源细节的关注，另一方...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"heketi","slug":"heketi","count":1,"path":"api/tags/heketi.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},{"title":"k8s之共享存储(GlusterFS)(三)","uid":"60ad9b5a7955245986176acd6be5e193","slug":"k8s/3.k8s之共享存储","date":"2020-12-25T05:26:26.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/3.k8s之共享存储.json","keywords":"golang rust python docker k8s","cover":null,"text":"K8S共享存储介绍 K8S 对于有状态的容器应用 或者 需要数据持久化的数据应用，不仅需要将容器内的目录挂载到宿主机的目录或者emptyDir临时存储卷，而且需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。 为了方便使用和管理，K8S实现...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"},{"name":"GlusterFS","slug":"GlusterFS","count":2,"path":"api/tags/GlusterFS.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"k8s之基础概念理解(二)","uid":"3ded30373967d6211e6c798b6bf7e484","slug":"k8s/2.k8s之基础概念理解","date":"2020-12-07T06:12:09.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/2.k8s之基础概念理解.json","keywords":"golang rust python docker k8s","cover":[],"text":"本篇主要来解释一下k8s繁多的概念 我觉得吧第一遍不用一定要全部理解，先大致过一下，以后会慢慢熟悉 K8S中的概念按我的理解把他分为这样两类： 架构类：所谓架构类，就是指K8S自身部署，调度，的一些组件和概念 服务类：就是针对我们自己的服务调度，部署，控制，所用到的概念 架构类 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"记一次磁盘满后引发的血案","uid":"0fd644d7a8607c81bbe89c11e736a98e","slug":"work/记一次磁盘满后引发的血案","date":"2020-12-07T05:37:12.000Z","updated":"2021-12-11T02:10:04.781Z","comments":true,"path":"api/articles/work/记一次磁盘满后引发的血案.json","keywords":"golang rust python docker k8s","cover":null,"text":"概要 微服务项目， 部署于docker swarm集群 docker swarm集群 是一台物理服务器 + 物理服务器自身虚拟出来的 四个节点，也就是总共五个节点所组成。 我们的中间件有 ELK, MySQL, Redis, RabbitMQ, DFS, ETCD，+上 大量的服...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"work-record","slug":"work-record","count":1,"path":"api/categories/work-record.json"}],"tags":[{"name":"工作记录","slug":"工作记录","count":1,"path":"api/tags/工作记录.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"k8s之搭建环境(一)","uid":"3ecf53fd0f043e7fd47d014c92e0e74b","slug":"k8s/1.k8s之搭建环境","date":"2020-11-27T05:18:17.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/k8s/1.k8s之搭建环境.json","keywords":"golang rust python docker k8s","cover":[],"text":"flag:从今天开始，我将更新K8S系列博文，从环境搭建，到K8S概念的详解，到在k8s上部署完整项目，乃至有可能对K8S的二次开发。未来可期 MAC1. 安装docker-desktop，这个没什么好说的 docker 2. 配置镜像仓库源进行加速 可以选择的源有很多 dock...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"k8s","slug":"k8s","count":4,"path":"api/categories/k8s.json"}],"tags":[{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"关于Golang高并发高效率代码的一些实践","uid":"771a458cad4b66e91f1476adf7a25646","slug":"golang/关于Golang高并发高效率代码的一些实践","date":"2020-11-18T09:49:19.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/关于Golang高并发高效率代码的一些实践.json","keywords":"golang rust python docker k8s","cover":[],"text":"Go的并发 Go语言是原生支持并发的，它和传统基于OS线程和进程的实现不同，Go语言的并发是基于用户态的并发，这种并发方式就变得非常轻量，能够轻松运行几万甚至是几十万的并发逻辑。因此使用Go开发的服务端应用采用的就是“协程模型”，每一个请求由独立的协程处理完成、 并发模型 Go的...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"高并发","slug":"高并发","count":1,"path":"api/tags/高并发.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"查看日志相关的命令","uid":"517d2648b07f96d72267ed192f3c0c92","slug":"guide/查看日志相关的命令","date":"2020-11-18T07:38:28.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/查看日志相关的命令.json","keywords":"golang rust python docker k8s","cover":null,"text":"作为一名开发，查询过滤日志去debug 应该是基本功中的基本功了。今天详细介绍一下这些命令 1. head head 与 tail 是一对命令，从字面意思也可以看出其作用 head 是用来查看头部的内容，tail 用来查看尾部的内容 参数： - -q 隐藏文件名 - -v 显示文...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"head","slug":"head","count":1,"path":"api/tags/head.json"},{"name":"grep","slug":"grep","count":1,"path":"api/tags/grep.json"},{"name":"tail","slug":"tail","count":1,"path":"api/tags/tail.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"MySQL之MVCC","uid":"94d8fb994bc3cd6f390288bebd2dcdbe","slug":"mysql/MySQL之MVCC","date":"2020-11-11T09:46:56.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL之MVCC.json","keywords":"golang rust python docker k8s","cover":null,"text":"什么是MVCC？ 英文全称为Multi-Version Concurrency Control,即多版本并发控制。但说到低其实本质上就是乐观锁（逻辑锁）的一种实现。适用于读提交以及默认的可重复读 的隔离级别。 原理 MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"python调用rust与go生成的库文件","uid":"9675eb8263b3ddc03bf1d31763c2e083","slug":"rust/python-rust-go","date":"2020-11-11T03:09:44.000Z","updated":"2021-12-11T02:10:04.781Z","comments":true,"path":"api/articles/rust/python-rust-go.json","keywords":"golang rust python docker k8s","cover":[],"text":"Python,Rust,Go 我最喜欢的三门语言。 今天来搞一下 分别用rust&amp;&amp;go生成.so文件供python调用，顺便简单测试一下他们之间的性能差距 版本 Python: 3.8.6 Go: 1.15.3 Rust: 1.49.0-nightly (25f...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"rust","slug":"rust","count":1,"path":"api/categories/rust.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"},{"name":"rust","slug":"rust","count":1,"path":"api/tags/rust.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"github-ssh协议配置代理","uid":"357905e1891b1f51272b4c207482f185","slug":"guide/github-ssh协议配置代理","date":"2020-11-10T07:10:01.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/github-ssh协议配置代理.json","keywords":"golang rust python docker k8s","cover":null,"text":"最近git连github经常抽风 使用 git config --global http.proxy的方式也没用的状态下，就想搞一下ssh协议走代理开搞 配置 .ssh/config Host github.com ProxyCommand ~&#x2F;.ssh&#x2F;ss...","link":"","photos":[],"count_time":{"symbolsCount":493,"symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"git","slug":"git","count":2,"path":"api/tags/git.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"详解MySQL的事务机制","uid":"63b43d983c23e0729b58ec6fc65ef6d7","slug":"mysql/详解MySQL的事务机制","date":"2020-11-10T05:56:05.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/详解MySQL的事务机制.json","keywords":"golang rust python docker k8s","cover":null,"text":"1. 什么是事务 事务就是一组原子性的sql查询，或者说一个独立的工作单元。即事务内的sql语句，要么全部执行成功，要么全部执行失败； 2. ACID 我们都知道事务的四大特性 原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"事务机制","slug":"事务机制","count":1,"path":"api/tags/事务机制.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"数据结构之链表","uid":"44f9b4429be4a923b3d82ea9a6628937","slug":"ds/数据结构之链表","date":"2020-10-30T05:14:02.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/ds/数据结构之链表.json","keywords":"golang rust python docker k8s","cover":[],"text":"1. 什么是链表 链表是由一组不必相连（可以连续也可以不连续）的内存结构节点，按特定的顺序链接在一起的抽象数据类型 2. 链表的分类 链表常用的有三类，单链表 双向链表 循环链表, 循环链表又分为单项与双向 3. 用Python来实现单向循环链表,其他的大同小异 一般会抽象如下方...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"数据结构之线性与非线性","uid":"80648934d5c19eeef307e3bc1f9a947e","slug":"ds/数据结构之线性与非线性","date":"2020-10-30T02:35:58.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/ds/数据结构之线性与非线性.json","keywords":"golang rust python docker k8s","cover":[],"text":"数据结构是计算机存储组织数据的方式，常见的数据结构分类如下图： 线性结构 什么是线性结构？ 数据结构中线性结构指的是数据元素之间存在着 一对一 的线性关系的数据结构。线性结构是一个有序数据元素的集合。 线性结构的特点- 线性结构有唯一的首元素（第一个元素）- 线性结构有唯一的尾元...","link":"","photos":[],"count_time":{"symbolsCount":597,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"MySQL8的新特性","uid":"c9eed3f9b00e09f8e1c1149f26ce6969","slug":"mysql/MySQL8的新特性","date":"2020-10-29T07:36:48.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/MySQL8的新特性.json","keywords":"golang rust python docker k8s","cover":[],"text":"MySQL的版本一下子跳跃这么大，用手指想就有很多新的东西了。下面我们就来详细了解一下。 1. 秒级加列 分别在5.7与8.0中有一张 test 表，数据为3000w行 # mysql8.0.22 mysql&gt; alter table test add str varcha...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"讲明白倒排索引","uid":"e31f27ca5c997bccd8e8b4c8d00251b5","slug":"es/讲明白倒排索引","date":"2020-10-28T09:24:17.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/es/讲明白倒排索引.json","keywords":"golang rust python docker k8s","cover":[],"text":"要搞明白倒排索引我们就要先搞明白什么是正排索引 对于搜索引擎来讲，正排索引是文档id到文档内容以及单词的关联关系，也就是说通过id获取到文档的内容，如果拿关系型数据库来解释就是下面这条SQL select * from human where id &#x3D; 3; 倒排索引 ...","link":"","photos":[],"count_time":{"symbolsCount":663,"symbolsTime":"1 mins."},"categories":[{"name":"es","slug":"es","count":2,"path":"api/categories/es.json"}],"tags":[{"name":"倒排索引","slug":"倒排索引","count":1,"path":"api/tags/倒排索引.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"关于RabbitMQ消息队列的可靠性传输","uid":"bd281a987a5c824ac404d854e69b882e","slug":"mq/关于RabbitMQ消息队列的可靠性传输","date":"2020-10-28T05:21:20.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mq/关于RabbitMQ消息队列的可靠性传输.json","keywords":"golang rust python docker k8s","cover":null,"text":"在使用消息队列的过程中如何保证消息的可靠性呢？这个问题其实包含了几方面的小问题。 数据丢失问题 数据幂等性的问题 重复消费的问题 我们知道在使用消息队列的时候是必然有三个角色的，生产者，消费者，以及MQ本身。那么数据丢失无非就以下几种情况 生产者传输给MQ 这个过程丢失数据，导致...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"消息队列","slug":"消息队列","count":1,"path":"api/categories/消息队列.json"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","count":1,"path":"api/tags/rabbitmq.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之访问者模式","uid":"6861080263609c8f32ead8d0fe52b3fb","slug":"golang/dp/理解设计模式之访问者模式","date":"2020-10-27T08:17:55.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之访问者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"访问者模式主要是为了解决 稳定数据结构与变化的数据操作 耦合的问题。可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。 package main import &quot;fmt&quot;...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之责任链模式","uid":"4d590d0702a24ddaf8b311434285f6b8","slug":"golang/dp/理解设计模式之责任链模式","date":"2020-10-27T07:56:07.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之责任链模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"责任链模式：分离不同职责 动态的组合相关责任链责任链上的处理者负责处理请求。客户端只需要发送即可这里举一个 通俗易懂的例子，叫家人帮我买手机！ package main import &quot;fmt&quot; &#x2F;&#x2F; 定义一个购买手机的需求 type Re...","link":"","photos":[],"count_time":{"symbolsCount":872,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之解释器模式","uid":"f06ad8235feac5c0bb5f9c61b04ab4af","slug":"golang/dp/理解设计模式之解释器模式","date":"2020-10-27T07:28:27.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之解释器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。 package main import &qu...","link":"","photos":[],"count_time":{"symbolsCount":821,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之备忘录模式","uid":"31a528ce1cc912e617e7cd21630fdad9","slug":"golang/dp/理解设计模式之备忘录模式","date":"2020-10-27T07:08:52.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之备忘录模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"备忘录，字面意思，一般会用来保存程序快照。或者 将内部程序的状态暴露给 外部，而不展示具体细节 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义备忘录接口 type Memo interface &#123; Save() M...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之状态模式","uid":"57343b3b347c194726d5fcd7c1e57903","slug":"golang/dp/理解设计模式之状态模式","date":"2020-10-27T06:58:29.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之状态模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"状态模式没啥好说的，就是用来分离行为与状态的。直接看例子 package main import &quot;fmt&quot; type Week interface &#123; Today() Next(*DayContext) &#125; type DayContext...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之策略模式","uid":"8edf5cc3c2cccf16484400f87c198799","slug":"golang/dp/理解设计模式之策略模式","date":"2020-10-27T06:51:40.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之策略模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"策略模式一般是用来封装一系列的算法，让这些算法可以在运行时互换。复合开闭原则 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义付款对象 type Payment struct &#123; context *PaymentCo...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之模板方法模式","uid":"047033f0c1450db28daf35058b5fd01e","slug":"golang/dp/理解设计模式之模板方法模式","date":"2020-10-27T02:23:35.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之模板方法模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"模版方法模式使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则。注意匿名组合虽然像继承，但还是有不一样的地方的。比如，因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用 package main impor...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之迭代器模式","uid":"293d39b9d616d2268ed47b9219110ea6","slug":"golang/dp/理解设计模式之迭代器模式","date":"2020-10-27T01:35:19.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之迭代器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"迭代器模式，一样的一个字面意思，封装你的对象 对外提供一个迭代器，可以不断迭代你的对象，这样外部无需了解对象的具体实现细节，通过迭代器就可以不断访问下一个元素 package main import &quot;container&#x2F;list&quot; &#x2F;&#...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之命令模式","uid":"2f495e9970023abb3de380eead14299f","slug":"golang/dp/理解设计模式之命令模式","date":"2020-10-26T10:05:50.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之命令模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。 示例中把主板单中的启动(start)方法和重启(reboot)方法封装为命令对象，再传递到主机(box)对象中。于两个按钮进行绑定： 第一个机箱(box1)设置按钮1(buttion1) 为开机按钮2(but...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之观察者模式","uid":"53fbeba8ed5d161cf25f38b1905c9c66","slug":"golang/dp/理解设计模式之观察者模式","date":"2020-10-26T09:55:25.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之观察者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"观察者模式比较好理解，就是字面意思，其实和发布订阅差不多。举一个学生订阅课程的例子 package main &#x2F;&#x2F; 定义课程接口 type ISubject interface &#123; Attach(IObserver) &#x2F;&#x2F; 添加观...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之中介者模式","uid":"2f29c37507db5ca2a228334b44c7a06a","slug":"golang/dp/理解设计模式之中介者模式","date":"2020-10-26T09:39:55.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之中介者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"中介者模式是用来封装对象与对象之间的交互，使依赖变简单，使复杂交互简单化，封装在中介者中，显而易见的缺点就是，由于逻辑封装在中介者中，所以中介者以后会越来越复杂 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义中介者类 typ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之桥接模式","uid":"4e7dab327a16c4ff4445f675a754b4bd","slug":"golang/dp/理解设计模式之桥接模式","date":"2020-10-26T06:54:02.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之桥接模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"桥接模式分离抽象部分和实现部分。使得两部分可以独立扩展。 package main import &quot;fmt&quot; &#x2F;&#x2F; 抽象消息接口 定义具体的消息类型 type AbsMessage interface &#123; SendMessage(...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之装饰器模式","uid":"f0bac87a6e91ff11c8f0bc84046165ce","slug":"golang/dp/理解设计模式之装饰器模式","date":"2020-10-26T06:38:34.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之装饰器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"熟悉python的朋友对装饰器肯定不陌生，他的定义就是在不改变原有定义的情况下，动态的添加功能。这里的装饰器模式其实也是一个意思 首先来看一个最简单的,在go中函数是一等公民，所以是可以当成参数传递的，那么这就简单了。 func pprint() &#123; fmt.Print...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之享元模式","uid":"0e88d00be424e9da6d7f13b5a9de850e","slug":"golang/dp/理解设计模式之享元模式","date":"2020-10-26T06:22:51.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之享元模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"享元模式是指：从对象中剥离出不发生改变且多个实例都需要的重复数据（当然这个数据也可以是对象），独立出一个享元，从而减少对象的创建，节省内存 package main import &quot;fmt&quot; type ImageFactory struct &#123; ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之组合模式","uid":"ae24c711008000da26e897d1dea4a2e7","slug":"golang/dp/理解设计模式之组合模式","date":"2020-10-26T05:37:01.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之组合模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"组合模式可以统一对象以及对象集，之后可以使用相同接口去访问这些对象和对象集组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。 这里咱们就直接创建一个树。 package main import ( &quot;log&quot; ) &...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之代理模式","uid":"0cc18532576f0420deb16181e5056f24","slug":"golang/dp/理解设计模式之代理模式","date":"2020-10-26T03:26:47.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之代理模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"代理模式用于延迟处理操作或者在进行实际操作前后进行其它处理。 package main import &quot;fmt&quot; type Work interface &#123; Do() string &#125; type RealWork struct&#123;&...","link":"","photos":[],"count_time":{"symbolsCount":708,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之适配器模式","uid":"81dbbf6776f0e83a5de64679463cd385","slug":"golang/dp/理解设计模式之适配器模式","date":"2020-10-26T03:20:15.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之适配器模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"适配器模式用于转换一种接口适配另一种接口。 package main import &quot;fmt&quot; &#x2F;&#x2F; Target 是适配的目标接口 type Target interface &#123; Request() string &#125; ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之外观模式","uid":"9b3ae101f06841603467d83a4a546e9c","slug":"golang/dp/理解设计模式之外观模式","date":"2020-10-26T02:52:42.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之外观模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"外观模式的主要作用是 减少客户端与系统内部交互的复杂性，对子系统的一系列接口，提供一个一致性的界面，方便调用 package main import &quot;fmt&quot; func NewAPI() FacadeAPI &#123; return &amp;apiImp...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"结构型设计模式","slug":"结构型设计模式","count":7,"path":"api/tags/结构型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之原型模式","uid":"ff7986bd3e13e58f395ae3555d928c50","slug":"golang/dp/理解设计模式之原型模式","date":"2020-10-23T12:08:31.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之原型模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"原型模式和其他创建型模式不一样的是，它是复制一个已有对象，而不是创建一个新对象，被复制的对象就叫做原型。原型模式多用于建造复杂或者耗时的对象，这样直接复制会比较高效。原型对象一般会配合原型管理器一起使用 go package main import ( &quot;fmt&quo...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之单例模式","uid":"1602c992a6a28c4ed33dd66720a6bf2e","slug":"golang/dp/理解设计模式之单例模式","date":"2020-10-23T12:05:12.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之单例模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"go语言中的单例模式简单到没啥可说的。 正常创建一个全局变量就是，单例为了线程安全你可以加锁，这里直接使用sync.once,原理一样。 go package main import &quot;sync&quot; type Singleton struct&#123;&#12...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之建造者模式","uid":"c3aea0285a3783cfb28818d4df287ed0","slug":"golang/dp/理解设计模式之建造者模式","date":"2020-10-23T11:05:37.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之建造者模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"建造者模式主要作用是解耦了创建的过程,将一个复杂对象的创建过程分步完成.下面来讲两种风格的建造者模式 gopackage main import &quot;fmt&quot; &#x2F;&#x2F; 1.传统类型: 由指挥者指挥建造者创建具体的对象 &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之抽象工厂","uid":"c1243241d6dbe40f7f47b73a2a79fbcc","slug":"golang/dp/理解设计模式之抽象工厂","date":"2020-10-23T10:54:34.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之抽象工厂.json","keywords":"golang rust python docker k8s","cover":null,"text":"抽象工厂 是在工厂方法的基础之上进化而来，其中最大的不同点是：工厂方法模式中的工厂 只创建一种对象，而抽象工厂中的工厂 则是创建多种对象，而往往这些对象是有关联的，一个家族的一系列对象，比如 订单和订单详情 go &#x2F;&#x2F; 订单信息接口 type Order in...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之工厂方法模式","uid":"ac7a60db5b9b5c38555c42db8dd8bf35","slug":"golang/dp/理解设计模式之工厂方法模式","date":"2020-10-23T09:40:20.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之工厂方法模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"与简单工厂不同，简单工厂 &#x3D; 一个工厂创造所有的 类对象，如果此对象在工厂中没有，就只能修改代码 去新增对象的创造过程而工厂方法 则只是定义了一系列的接口， 定义创建对象的接口，定义工厂的接口，具体的工厂对象，以及 产品 对象 都由外部自己实现。 相当于只是定义了规则 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"},{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"理解设计模式之简单工厂","uid":"66121ee3bb53d4eaf9b18fd8c88d13c8","slug":"golang/dp/理解设计模式之简单工厂","date":"2020-10-23T09:27:12.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之简单工厂.json","keywords":"golang rust python docker k8s","cover":null,"text":"所谓简单工厂是指 用来封装一个类对象的具体创建细节，去构造一个对象在go语言中没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。 package factory impor...","link":"","photos":[],"count_time":{"symbolsCount":687,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"创建型设计模式","slug":"创建型设计模式","count":6,"path":"api/tags/创建型设计模式.json"},{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"折腾之在CentOS8上安装K8s环境(废弃)","uid":"9de8279fb9a993c3fcae6823edce7c19","slug":"centos/折腾centos8","date":"2020-10-21T05:29:21.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/centos/折腾centos8.json","keywords":"golang rust python docker k8s","cover":null,"text":"（红帽不想让我们白嫖了，GG）继续centos7，也可以慢慢转向debian了centos8 已经出来一段时间了，在刚出来的时候，尝试过使用一次，貌似相较7变化有些大，就没继续折腾现在有时间了，来尝试一下把K8S的环境搭建在centos8上。 虚拟机 我用的是Parallels ...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"centos","slug":"centos","count":1,"path":"api/categories/centos.json"}],"tags":[{"name":"centos8","slug":"centos8","count":1,"path":"api/tags/centos8.json"},{"name":"k8s","slug":"k8s","count":5,"path":"api/tags/k8s.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"hexo添加评论系统","uid":"e58f8fe0572c85b85b5c4eee696e5d39","slug":"config/hexo添加评论系统","date":"2020-10-21T01:54:15.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/config/hexo添加评论系统.json","keywords":"golang rust python docker k8s","cover":[],"text":" hexo支持很多评论系统，由于我的blog是部署在github page 上，所以，索性我就直接用gitalk用做评论系统 配置方法 首先先在github中创建一个用于存储评论的公有仓库，注意（博客可以部署在私有仓库，评论必须public） 注册Github APP https...","link":"","photos":[],"count_time":{"symbolsCount":457,"symbolsTime":"1 mins."},"categories":[{"name":"hexo","slug":"hexo","count":2,"path":"api/categories/hexo.json"}],"tags":[{"name":"hexo","slug":"hexo","count":2,"path":"api/tags/hexo.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"DockerSwarm搭建完整的微服务项目","uid":"27852f8dc79cc34a496b7be5ae32dae9","slug":"golang/DockerSwarm搭建完整的微服务项目","date":"2020-10-20T06:59:52.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/DockerSwarm搭建完整的微服务项目.json","keywords":"golang rust python docker k8s","cover":null,"text":"这是一个容器化快速发展的时代，相信不少朋友都已经体会到了容器的便利性，自从我第一眼看到容器这个东西，就对其深深的爱上了。也确定了我以后的职业发展方向。这也是我喜欢Golang的原因 最近接到一个说大不大说下不小的项目，因为K8S有点太重了，我们人员资源有限，所以这一次我打算用do...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"docker","slug":"docker","count":2,"path":"api/categories/docker.json"}],"tags":[{"name":"docker","slug":"docker","count":2,"path":"api/tags/docker.json"},{"name":"swarm","slug":"swarm","count":1,"path":"api/tags/swarm.json"},{"name":"架构","slug":"架构","count":1,"path":"api/tags/架构.json"},{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"用简单的话讲明白MySQL索引","uid":"5a2cdee73626da8985a23805f627ad4f","slug":"mysql/用简单的话讲明白索引","date":"2020-10-20T01:57:21.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/mysql/用简单的话讲明白索引.json","keywords":"golang rust python docker k8s","cover":[],"text":"索引的作用顾名思义，索引其实就是字面意思，和我们以前查字典的索引是一样的意思，能够帮助我们快速的查找到相关数据，这就是索引，哈希表的键，人的名字，工号，身份证号，这些都是索引 BTree(B-Tree) B树和B-树其实是一个意思。它长这个样子 它是一颗多路平衡查找树，我们描述一...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":4,"path":"api/categories/MySQL.json"}],"tags":[{"name":"mysql","slug":"mysql","count":4,"path":"api/tags/mysql.json"},{"name":"数据库索引","slug":"数据库索引","count":1,"path":"api/tags/数据库索引.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"Golang程序Dockerfile最佳实践","uid":"e68c644f0327c9651998fad434541edf","slug":"docker/Golang程序Dockerfile最佳实践","date":"2020-10-16T08:51:49.000Z","updated":"2022-03-12T04:51:59.775Z","comments":true,"path":"api/articles/docker/Golang程序Dockerfile最佳实践.json","keywords":"golang rust python docker k8s","cover":[],"text":"众所周知，通过Dockerfile去构建镜像是分层执行的，\b如何使我们的镜像最小化，以及不会泄露源代码等，我总结一个比较通用的Dockerfile. FROM golang:latest as builder WORKDIR &#x2F;home&#x2F;works&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"docker","slug":"docker","count":2,"path":"api/categories/docker.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"},{"name":"docker","slug":"docker","count":2,"path":"api/tags/docker.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"Golang程序实现自动更新","uid":"26beaec8904420e53dae414f48ef2055","slug":"golang/Golang程序实现自动更新","date":"2020-10-16T08:03:06.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/Golang程序实现自动更新.json","keywords":"golang rust python docker k8s","cover":null,"text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;我们都知道一个正常的golang程序部署流程大致都要经过编译，测试，发布(人工或者自动化) ，在大公司基础设施完善，当然也未必。我现在就身处于一个上市公司，但是基础建设极其惨不忍睹的公司。扯远了。进入...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":5,"path":"api/tags/go.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"ElasticSearch之ScrollAPI","uid":"a96d6d6139d5419f25b0435643fa218f","slug":"es/ElasticSearch之ScrollAPI","date":"2020-10-16T07:07:23.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/es/ElasticSearch之ScrollAPI.json","keywords":"golang rust python docker k8s","cover":null,"text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;最近遇到了一个需求，公司集团的所有项目日志都是存在kafka中，通过logstash去不断读取，通过一定的规则将日志切割为我们需要的格式，存入ES。我们要做的就是定期不断的从ES中取获取日志，分析日志...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"es","slug":"es","count":2,"path":"api/categories/es.json"}],"tags":[{"name":"es","slug":"es","count":1,"path":"api/tags/es.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"工欲善其事,必先利其器","uid":"7dfbca418b659e3c01ba70280331af77","slug":"config/工欲善其事","date":"2020-10-14T08:58:32.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/config/工欲善其事.json","keywords":"golang rust python docker k8s","cover":[],"text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;俗话说的好，工欲善其事必先利其器，作为一名有追求的开发者，当然要将自己吃饭的家伙打造的即好用又美观啦。 &amp;#160;&amp;#160;&amp;#160;&amp;#160;接下来我主要会从...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"工具配置","slug":"工具配置","count":1,"path":"api/categories/工具配置.json"}],"tags":[{"name":"mac","slug":"mac","count":1,"path":"api/tags/mac.json"},{"name":"config","slug":"config","count":1,"path":"api/tags/config.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"Firewalld防火墙操作手册","uid":"215ed200ae4dc1e04195cbe144fde063","slug":"guide/Firewalld防火墙操作手册","date":"2020-10-14T08:30:18.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/guide/Firewalld防火墙操作手册.json","keywords":"golang rust python docker k8s","cover":null,"text":"firewalld的基本使用 启动: systemctl start firewalld 关闭: systemctl stop firewalld 查看状态: systemctl status firewalld 开机禁用: systemctl disable firewalld...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"firewalld","slug":"firewalld","count":1,"path":"api/tags/firewalld.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"Vim常用命令","uid":"c30c52bb5c9d540be0dfcb4f6b31a9fc","slug":"guide/Vim常用命令","date":"2020-10-14T05:43:56.000Z","updated":"2021-12-11T02:10:04.780Z","comments":true,"path":"api/articles/guide/Vim常用命令.json","keywords":"golang rust python docker k8s","cover":null,"text":"&amp;#160;&amp;#160;&amp;#160;&amp;#160;众所周知，vim是程序员的一款利器， 一些大神可以完全抛弃ide只使用vim去构建庞大的项目， 而对于我来说只是一个工具而已，他不应该耗费我的精力去做配置和学习，强行改变自己的编码习惯，所以这里整理了...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"vim","slug":"vim","count":1,"path":"api/tags/vim.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"hexo如何插入图片","uid":"7110b28ed6014c88f6bf2e9ca83fa56d","slug":"config/Hexo如何插入图片","date":"2020-10-14T05:42:20.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/config/Hexo如何插入图片.json","keywords":"golang rust python docker k8s","cover":null,"text":" 首先安装插件 npm install hexo-asset-image --save 编辑hexo配置文件_config.yml post_asset_folder: true 修改node_modules/hexo-asset-image/index.js 为如下内容 use...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"hexo","slug":"hexo","count":2,"path":"api/categories/hexo.json"}],"tags":[{"name":"hexo","slug":"hexo","count":2,"path":"api/tags/hexo.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"Git命令概览","uid":"99196e093c1a105719cfe8e1edea1c78","slug":"guide/Git命令速查表","date":"2020-10-13T03:22:28.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/guide/Git命令速查表.json","keywords":"golang rust python docker k8s","cover":[],"text":" 创建版本库 git clone url 克隆远程版本库 git init 初始化本地版本库 配置 git config --global user.name &#39;chengcp&#39; 配置global级别的用户名 git config --global user.em...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"操作指南","slug":"操作指南","count":5,"path":"api/categories/操作指南.json"}],"tags":[{"name":"git","slug":"git","count":2,"path":"api/tags/git.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"计算机基础之网络协议","uid":"bd1810b01d17021ef51e6fe61514d2b5","slug":"basic/计算机基础之网络协议","date":"2020-09-19T09:19:52.000Z","updated":"2022-03-12T06:12:23.355Z","comments":true,"path":"api/articles/basic/计算机基础之网络协议.json","keywords":"golang rust python docker k8s","cover":[],"text":"我们都知道OSI把网络分为了一个7层的模型，OSI是Open System Interconnect的缩写，意为开放式系统互联。 主要是： 应用层（Application） 表示层（Presentation） 会话层（Session） 传输层（Transport） 网络层（Net...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},{"title":"select poll epoll","uid":"5f7c30e057df77178fa3c740f5edfc89","slug":"basic/epoll","date":"2020-08-13T07:27:09.000Z","updated":"2021-12-11T02:10:04.777Z","comments":true,"path":"api/articles/basic/epoll.json","keywords":"golang rust python docker k8s","cover":null,"text":"今天被问到epoll机制，倒不是不知道，就是长时间不看他就容易忽略一些细节，导致描述不好。好吧那我们就来复习一下吧。（虽然我向来不是一个面向面试编程的人）-.&#x3D; 首先 select,poll,epoll都是I&#x2F;O多路复用的机制。I&#x2F;O多路复用：通过一...","link":"","photos":[],"count_time":{"symbolsCount":816,"symbolsTime":"1 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":2,"path":"api/categories/计算机基础.json"}],"tags":[{"name":"epoll","slug":"epoll","count":1,"path":"api/tags/epoll.json"},{"name":"poll","slug":"poll","count":1,"path":"api/tags/poll.json"},{"name":"select","slug":"select","count":1,"path":"api/tags/select.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}],"categories":17,"tags":79,"word_count":"133k","post_count":56}