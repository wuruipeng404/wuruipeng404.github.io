{"title":"http,https,http2,RPC,gRPC,Socket,WebSocket都是些啥","uid":"d71352f907ccd4a5fa2d2fd4965d3b21","slug":"basic/proto","date":"2021-08-12T06:07:20.000Z","updated":"2022-03-13T03:50:27.352Z","comments":true,"path":"api/articles/basic/proto.json","keywords":"golang rust python docker k8s","cover":[],"content":"<p>首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层</p>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h3><ul>\n<li><code>http</code>,<code>https</code>,<code>http2</code> (统称<code>http</code>) 是应用层协议，主要解决如何包装数据（文本信息），是建立在<code>TCP</code>协议之上的应用。那么这个s,和2分别指的什么呢<br>我们来先看一下http的发展史<table>\n<thead>\n<tr>\n<th align=\"center\">版本</th>\n<th align=\"center\">产生时间</th>\n<th align=\"center\">内容</th>\n<th align=\"center\">发展现状</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">http&#x2F;0.9</td>\n<td align=\"center\">1991年</td>\n<td align=\"center\">不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求</td>\n<td align=\"center\">没有作为正式标准</td>\n</tr>\n<tr>\n<td align=\"center\">http&#x2F;1.0</td>\n<td align=\"center\">1996年</td>\n<td align=\"center\">传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令</td>\n<td align=\"center\">正式作为标准</td>\n</tr>\n<tr>\n<td align=\"center\">http&#x2F;1.1</td>\n<td align=\"center\">1997年</td>\n<td align=\"center\">持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td>\n<td align=\"center\">使用最为广泛</td>\n</tr>\n<tr>\n<td align=\"center\">http&#x2F;2</td>\n<td align=\"center\">2015年</td>\n<td align=\"center\">多路复用、服务器推送、头信息压缩、二进制协议等</td>\n<td align=\"center\">逐渐覆盖市场</td>\n</tr>\n</tbody></table>\n  那么看到这里,大家就知道了 <code>http2</code> 其实就是<code>http</code>的版本号, 而我们正常说的<code>http</code>一般指的是<code>http/1.1</code></li>\n</ul>\n<span id=\"more\"></span>\n\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><p>我们都知道<code>http</code>传输的数据都是以明文进行传输的,这样就会带来安全问题, 而<code>https</code>就是在<code>http</code>之上使用<code>SSL</code>或<code>TLS</code>提供加密处理数据、验证对方身份以及数据完整性保护</p>\n<ul>\n<li><p>这里用一张图演示一下交互过程<br><img src=\"/images/basic/https.png\" alt=\"https\"></p>\n</li>\n<li><p><code>https</code>在传输的过程中会涉及到三个密钥：</p>\n<ul>\n<li>服务器端的公钥和私钥，用来进行非对称加密</li>\n<li>客户端生成的随机密钥，用来进行对称加密</li>\n</ul>\n</li>\n<li><p>一个<code>https</code>请求实际上包含了两次<code>http</code>传输，可以细分为8步。</p>\n</li>\n</ul>\n<ol>\n<li>客户端向服务器发起<code>https</code>请求，连接到服务器的443端口</li>\n<li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li>\n<li>服务器将自己的公钥发送给客户端。</li>\n<li>客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么<code>https</code>传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，<code>https</code>中的第一次http请求结束。</li>\n<li>客户端会发起<code>https</code>中的第二个<code>http</code>请求，将加密之后的客户端密钥发送给服务器。</li>\n<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li>\n<li>然后服务器将加密后的密文发送给客户端。</li>\n<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样<code>https</code>中的第二个http请求结束，整个<code>https</code>传输完成。</li>\n</ol>\n<h3 id=\"http2\"><a href=\"#http2\" class=\"headerlink\" title=\"http2\"></a>http2</h3><ul>\n<li>特性<ol>\n<li><p>新的二进制格式</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>http1.x</code>都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。</p></blockquote>\n</li>\n<li><p>多路复用</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>多个request共享一个连接。</p></blockquote>\n</li>\n<li><p>header压缩</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在<code>http1.x</code>中header信息很多，且每次都会重复发送，造成很大浪费。<code>http2</code>使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。</p></blockquote>\n</li>\n<li><p>服务端推送</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。</p></blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><p>(Remote Procedure Call)叫做远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。</p>\n<ul>\n<li><p>为何有<code>http</code>协议之后，还要<code>RPC</code>调用？</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>RPC</code>跟<code>http</code>不是对立面，<code>RPC</code>中可以使用<code>http</code>作为通讯协议。<code>RPC</code>是一种设计、实现框架，通讯协议只是其中一部分。<br><code>RPC</code>的本质是提供了一种轻量无感知的跨进程通信的方式，在分布式机器上调用其他方法与本地调用无异（远程调用的过程是透明的，你并不知道这个调用的方法是部署在哪里，通过<code>RPC</code>能够解耦服务）。RPC是根据语言的API来定义的，而不是基于网络的应用来定义的，调用更方便，协议私密更安全、内容更小效率更高。<br><code>http</code>接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的<code>http</code>协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，<code>RPC</code>框架的好处就显示出来了</p></blockquote>\n<ol>\n<li>首先（基于<code>TCP</code>协议的情况下）就是长链接，不必每次通信都要像<code>http</code> 一样去3次握手什么的，减少了网络开销；</li>\n<li>其次就是<code>RPC</code>框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。</li>\n<li>最后就是最近流行的服务化架构、服务化治理，<code>RPC</code>框架是一个强力的支撑。</li>\n</ol>\n</li>\n<li><p><code>RPC</code> 中要解决的问题</p>\n<ol>\n<li>建立通信：在客户端与服务端建立起数据传输通道，大都是<code>TCP</code>连接（<code>gRPC</code>使用了<code>http2</code>）。</li>\n<li>寻址：A服务器上的应用需要告诉<code>RPC</code>框架：B服务器地址、端口，调用函数名称。所以必须实现待调用方法到call ID的映射。</li>\n<li>序列化与反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先要序列化成二进制，B服务器收到请求后要再对参数进行反序列化。恢复为内存中的表达方式，找到对应的方法进行本地调用，得到返回值。返回值从B到A的传输仍要经过序列化与反序列化的过程。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p><code>gRPC</code>是谷歌开源的一个 <code>RPC</code> 框架，面向移动和 <code>http2</code> 设计。</p>\n<p>内容交换格式采用<code>ProtoBuf</code>(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与<code>XML</code>，<code>Json</code>类似，但使用二进制，（反）序列化速度快，压缩效率高。<br>传输协议 采用<code>http2</code>，性能比<code>http1.1</code>好了很多<br>和很多<code>RPC</code>系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用<code>gPRC</code>支持的不同语言实现。</p>\n<p><code>ProtoBuf</code> 具有强大的<code>IDL</code>（interface description language，接口描述语言）和相关工具集（主要是<code>protoc</code>）。用户写好.proto描述文件后，<code>protoc</code>可以将其编译成众多语言的接口代码。<br>目前很多微服务框架都使用的是这一套, 比如<code>Golang</code>中的 <a href=\"https://github.com/asim/go-micro\">Go-Micro</a></p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>要搞明白socket, 我们得先看看 网络模型中的 传输层, 像<code>http</code>协议是运行在应用层之上一样,哪些协议运行在传输层呢? 一般有<code>TCP,UDP,RTP,SCTP等等</code>,而传输层的协议一般就是用来解决数据如何在网络中传输的.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>而 <code>socket</code> 就是 <code>TCP</code>与<code>UDP</code>的具体接口实现, 用于面向开发者的一个入口</p></blockquote>\n<h3 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h3><ul>\n<li>第一次看到这个名词,一般都会生出一个疑问, 它和<code>Socket</code>有什么区别与联系?这个问题非常好回答.. 就像 <code>java</code> 与 <code>javascript</code>, <code>雷锋</code> 与 <code>雷峰塔</code> 一样..<br><code>websocket</code> 其实与 <code>http</code> 一样也是应用层协议,用于客户端与服务端进行数据传输, 那为什么我们有已经有<code>http</code>协议后,还需要一个<code>websocket</code>呢? 有什么好处呢? 答案很简单, 因为<code>http</code>通信只能由客户端进行发起,服务端无法主动推送.<br><code>webSocket</code> 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href=\"https://en.wikipedia.org/wiki/Push_technology\">服务器推送技术</a>的一种。</p></blockquote>\n</li>\n<li>其特点如下:</li>\n</ul>\n<ol>\n<li>建立在 <code>TCP</code> 协议之上，服务器端的实现比较容易。</li>\n<li>与 <code>http</code> 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 <code>http</code> 协议，因此握手时不容易屏蔽，能通过各种 <code>http</code> 代理服务器。</li>\n<li>数据格式比较轻量，性能开销小，通信高效。</li>\n<li>可以发送文本，也可以发送二进制数据。</li>\n<li>没有同源限制，客户端可以与任意服务器通信。</li>\n<li>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</li>\n</ol>\n<ul>\n<li><code>websocket</code> 与<code>http/2</code> 对比</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">http&#x2F;2</th>\n<th align=\"center\">WebSocket</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">请求头</td>\n<td align=\"center\">压缩(HPACK算法)</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">二进制    √</td>\n<td align=\"center\">二进制或文本流</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">多路复用</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">优先级</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n</tr>\n<tr>\n<td align=\"center\">压缩</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">方向</td>\n<td align=\"center\">客户端&#x2F;服务器+服务器端推送（Server Push）</td>\n<td align=\"center\">双向的</td>\n</tr>\n<tr>\n<td align=\"center\">全双工</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n</tbody></table>\n","feature":true,"text":"首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层 http http,https,http2 (统称http) 是应用层协议，主要解决如何包装数据（文本信息），是建立在TCP协议之上的应用。那么这个s,和2分别指的什么呢我们来先...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"网络基础","slug":"网络基础","count":1,"path":"api/categories/网络基础.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http\"><span class=\"toc-text\">http</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#https\"><span class=\"toc-text\">https</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#http2\"><span class=\"toc-text\">http2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RPC\"><span class=\"toc-text\">RPC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gRPC\"><span class=\"toc-text\">gRPC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Socket\"><span class=\"toc-text\">Socket</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#WebSocket\"><span class=\"toc-text\">WebSocket</span></a></li></ol>","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"推荐一些我觉得比较有意思的开源项目","uid":"e32e933f33758e391059ab380b68ec99","slug":"config/project","date":"2021-10-12T12:31:56.000Z","updated":"2022-03-13T03:50:08.106Z","comments":true,"path":"api/articles/config/project.json","keywords":"golang rust python docker k8s","cover":null,"text":" name description mkcert 在本地快速搭建https环境 grmon 命令行监控goroutine Golang版本的diagrams 用代码画图 lazykube 在终端用鼠标管理k8s集群 pyroscope 用来分析程序的性能问题 bubbletea ...","link":"","photos":[],"count_time":{"symbolsCount":300,"symbolsTime":"1 mins."},"categories":[{"name":"go","slug":"go","count":4,"path":"api/categories/go.json"},{"name":"work","slug":"go/work","count":1,"path":"api/categories/go/work.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"},{"name":"work","slug":"work","count":1,"path":"api/tags/work.json"},{"name":"project","slug":"project","count":1,"path":"api/tags/project.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true},"next_post":{"title":"封装易用的 Golang Odm","uid":"235660ba99baa3b7d4208214f0acb547","slug":"golang/odm","date":"2021-06-12T04:12:37.000Z","updated":"2022-03-13T03:49:44.819Z","comments":true,"path":"api/articles/golang/odm.json","keywords":"golang rust python docker k8s","cover":null,"text":"在golang中目前需要对mongodb进行操作会接触到如下两个库 mongo-go-driver mongodb官方出的驱动mgo mgo 很久没有维护了. 所以现在大家基本上都在使用官方的driver,但是官方的driver用下来,有一些痛点.所以我决定封装一下.使其用起来像...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"go","slug":"go","count":4,"path":"api/categories/go.json"},{"name":"mongo","slug":"go/mongo","count":1,"path":"api/categories/go/mongo.json"}],"tags":[{"name":"go","slug":"go","count":6,"path":"api/tags/go.json"},{"name":"mongodb","slug":"mongodb","count":1,"path":"api/tags/mongodb.json"},{"name":"odm","slug":"odm","count":1,"path":"api/tags/odm.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"feature":true}}