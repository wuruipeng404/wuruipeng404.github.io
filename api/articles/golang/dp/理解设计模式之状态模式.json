{"title":"理解设计模式之状态模式","uid":"57343b3b347c194726d5fcd7c1e57903","slug":"golang/dp/理解设计模式之状态模式","date":"2020-10-27T06:58:29.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之状态模式.json","keywords":"golang rust python docker k8s","cover":null,"content":"<p>状态模式没啥好说的，就是用来分离行为与状态的。直接看例子</p>\n<span id=\"more\"></span>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\ntype Week interface &#123;\n\tToday()\n\tNext(*DayContext)\n&#125;\n\ntype DayContext struct &#123;\n\ttoday Week\n&#125;\n\nfunc NewDayContext() *DayContext &#123;\n\treturn &amp;DayContext&#123;\n\t\ttoday: &amp;Sunday&#123;&#125;,\n\t&#125;\n&#125;\n\nfunc (d *DayContext) Today() &#123;\n\td.today.Today()\n&#125;\n\nfunc (d *DayContext) Next() &#123;\n\td.today.Next(d)\n&#125;\n\ntype Sunday struct&#123;&#125;\n\nfunc (*Sunday) Today() &#123;\n\tfmt.Printf(&quot;Sunday\\n&quot;)\n&#125;\n\nfunc (*Sunday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Monday&#123;&#125;\n&#125;\n\ntype Monday struct&#123;&#125;\n\nfunc (*Monday) Today() &#123;\n\tfmt.Printf(&quot;Monday\\n&quot;)\n&#125;\n\nfunc (*Monday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Tuesday&#123;&#125;\n&#125;\n\ntype Tuesday struct&#123;&#125;\n\nfunc (*Tuesday) Today() &#123;\n\tfmt.Printf(&quot;Tuesday\\n&quot;)\n&#125;\n\nfunc (*Tuesday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Wednesday&#123;&#125;\n&#125;\n\ntype Wednesday struct&#123;&#125;\n\nfunc (*Wednesday) Today() &#123;\n\tfmt.Printf(&quot;Wednesday\\n&quot;)\n&#125;\n\nfunc (*Wednesday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Thursday&#123;&#125;\n&#125;\n\ntype Thursday struct&#123;&#125;\n\nfunc (*Thursday) Today() &#123;\n\tfmt.Printf(&quot;Thursday\\n&quot;)\n&#125;\n\nfunc (*Thursday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Friday&#123;&#125;\n&#125;\n\ntype Friday struct&#123;&#125;\n\nfunc (*Friday) Today() &#123;\n\tfmt.Printf(&quot;Friday\\n&quot;)\n&#125;\n\nfunc (*Friday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Saturday&#123;&#125;\n&#125;\n\ntype Saturday struct&#123;&#125;\n\nfunc (*Saturday) Today() &#123;\n\tfmt.Printf(&quot;Saturday\\n&quot;)\n&#125;\n\nfunc (*Saturday) Next(ctx *DayContext) &#123;\n\tctx.today &#x3D; &amp;Sunday&#123;&#125;\n&#125;\n\nfunc main() &#123;\n\ttd :&#x3D; NewDayContext()\n\ttd.Next()\n\ttd.Today()\n&#125;</code></pre>\n","text":"状态模式没啥好说的，就是用来分离行为与状态的。直接看例子 package main import &quot;fmt&quot; type Week interface &#123; Today() Next(*DayContext) &#125; type DayContext...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"toc":"","author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}},"mapped":true,"prev_post":{"title":"理解设计模式之备忘录模式","uid":"31a528ce1cc912e617e7cd21630fdad9","slug":"golang/dp/理解设计模式之备忘录模式","date":"2020-10-27T07:08:52.000Z","updated":"2021-12-11T02:10:04.778Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之备忘录模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"备忘录，字面意思，一般会用来保存程序快照。或者 将内部程序的状态暴露给 外部，而不展示具体细节 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义备忘录接口 type Memo interface &#123; Save() M...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}},"next_post":{"title":"理解设计模式之策略模式","uid":"8edf5cc3c2cccf16484400f87c198799","slug":"golang/dp/理解设计模式之策略模式","date":"2020-10-27T06:51:40.000Z","updated":"2021-12-11T02:10:04.779Z","comments":true,"path":"api/articles/golang/dp/理解设计模式之策略模式.json","keywords":"golang rust python docker k8s","cover":null,"text":"策略模式一般是用来封装一系列的算法，让这些算法可以在运行时互换。复合开闭原则 package main import &quot;fmt&quot; &#x2F;&#x2F; 定义付款对象 type Payment struct &#123; context *PaymentCo...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":24,"path":"api/categories/设计模式.json"}],"tags":[{"name":"行为型设计模式","slug":"行为型设计模式","count":11,"path":"api/tags/行为型设计模式.json"}],"author":{"name":"Rumple","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"不断学习 才能更加强大","socials":{"github":"https://github.com/wuruipeng404","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/images/mail.png","link":"mailto:wrp357711589@163.com"}}}}}}